####################################################################
### Oracle 19c Migration from NonCDB to PDB on OEL 7.9 by AzizPW ###
### Technical Consulting Manager ###################################
### PT Mitra Integrasi Informatika #################################
### Tue, 23 Feb 2021 ###############################################
####################################################################

There are two instances on this server:
ORACLE_SID=lemper as NonCDB
ORACLE_SID=cpempek as CDB

Reference:
https://oracle-base.com/articles/12c/multitenant-migrate-non-cdb-to-pdb-12cr1#clone-remote-non-cdb

[oracle@bakso ~]$ ps -ef|grep pmon
oracle    9077     1  0 11:40 ?        00:00:00 ora_pmon_lemper
oracle   11527  3058  0 12:14 pts/0    00:00:00 grep --color=auto pmon
[oracle@bakso ~]$ export ORACLE_SID=lemper
[oracle@bakso ~]$ rlwrap sqlplus '/ as sysdba'

SQL*Plus: Release 19.0.0.0.0 - Production on Tue Feb 23 12:15:22 2021
Version 19.10.0.0.0

Copyright (c) 1982, 2020, Oracle.  All rights reserved.


Connected to:
Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.10.0.0.0

SQL> select db_unique_name,open_mode from v$database;

DB_UNIQUE_NAME                 OPEN_MODE
------------------------------ --------------------
lemper                         READ WRITE

Elapsed: 00:00:00.01
SQL> select CON_ID,name,open_mode from v$containers;

    CON_ID NAME                                                                                                                             OPEN_MODE
---------- -------------------------------------------------------------------------------------------------------------------------------- ----------
         0 lemper                                                                                                                           READ WRITE

Elapsed: 00:00:00.01
SQL> show pdbs;
SQL> shu immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> startup open read only;
ORACLE instance started.

Total System Global Area 1610609192 bytes
Fixed Size                  8897064 bytes
Variable Size             603979776 bytes
Database Buffers          989855744 bytes
Redo Buffers                7876608 bytes
Database mounted.
Database opened.
SQL> select db_unique_name,open_mode from v$database;

DB_UNIQUE_NAME                 OPEN_MODE
------------------------------ --------------------
lemper                         READ ONLY

Elapsed: 00:00:00.01
SQL> BEGIN
  2  DBMS_PDB.DESCRIBE(pdb_descr_file => '/tmp/lemper_20210223.xml');
  3  END;
  4  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:03.02
SQL> shu immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> exit
Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.10.0.0.0
[oracle@bakso ~]$ ls -lh /tmp/lemper_20210223.xml
-rw-r--r--. 1 oracle oinstall 6.7K Feb 23 12:30 /tmp/lemper_20210223.xml
[oracle@bakso ~]$ source ~/.bash_profile
[oracle@bakso ~]$ env|grep ORA
ORACLE_SID=cpempek
ORACLE_BASE=/z01/app/oracle
ORACLE_HOSTNAME=bakso.food.net
ORA_INVENTORY=/z01/app/oraInventory
ORACLE_HOME=/z01/app/oracle/product/19.0.0/dbhome_1
[oracle@bakso ~]$ rlwrap sqlplus '/ as sysdba'

SQL*Plus: Release 19.0.0.0.0 - Production on Tue Feb 23 12:33:39 2021
Version 19.10.0.0.0

Copyright (c) 1982, 2020, Oracle.  All rights reserved.

Connected to an idle instance.

SQL> startup;
ORACLE instance started.

Total System Global Area 1610609280 bytes
Fixed Size                  9138816 bytes
Variable Size            1040187392 bytes
Database Buffers          553648128 bytes
Redo Buffers                7634944 bytes
Database mounted.
Database opened.
SQL> select CON_ID,name,open_mode from v$containers;

    CON_ID NAME                                                                                                                             OPEN_MODE
---------- -------------------------------------------------------------------------------------------------------------------------------- ----------
         1 CDB$ROOT                                                                                                                         READ WRITE
         2 PDB$SEED                                                                                                                         READ ONLY
         3 PLENJER                                                                                                                          MOUNTED

Elapsed: 00:00:00.00
SQL> alter pluggable database all open;

Pluggable database altered.

Elapsed: 00:00:10.18
SQL> select CON_ID,name,open_mode from v$containers;

    CON_ID NAME                                                                                                                             OPEN_MODE
---------- -------------------------------------------------------------------------------------------------------------------------------- ----------
         1 CDB$ROOT                                                                                                                         READ WRITE
         2 PDB$SEED                                                                                                                         READ ONLY
         3 PLENJER                                                                                                                          READ WRITE

Elapsed: 00:00:00.00
SQL> !mkdir -p /data01/padaan

SQL> CREATE PLUGGABLE DATABASE padaan USING '/tmp/lemper_20210223.xml' COPY FILE_NAME_CONVERT = ('/data01/LEMPER/', '/data01/padaan/');

Pluggable database created.

Elapsed: 00:02:46.32
SQL> select CON_ID,name,open_mode from v$containers;

    CON_ID NAME                                                                                                                             OPEN_MODE
---------- -------------------------------------------------------------------------------------------------------------------------------- ----------
         1 CDB$ROOT                                                                                                                         READ WRITE
         2 PDB$SEED                                                                                                                         READ ONLY
         3 PLENJER                                                                                                                          READ WRITE
         4 PADAAN                                                                                                                           MOUNTED

Elapsed: 00:00:00.00
SQL> ALTER SESSION SET CONTAINER=padaan;

Session altered.

Elapsed: 00:00:00.19
SQL> select CON_ID,name,open_mode from v$containers;

    CON_ID NAME                                                                                                                             OPEN_MODE
---------- -------------------------------------------------------------------------------------------------------------------------------- ----------
         4 PADAAN                                                                                                                           MOUNTED

Elapsed: 00:00:00.01
SQL> @?/rdbms/admin/noncdb_to_pdb.sql
SQL> SET FEEDBACK 1
SQL> SET NUMWIDTH 10
SQL> SET LINESIZE 80
SQL> SET TRIMSPOOL ON
SQL> SET TAB OFF
SQL> SET PAGESIZE 100
SQL> SET VERIFY OFF
SQL>
SQL> WHENEVER SQLERROR EXIT;
SQL>
SQL> DOC
DOC>#######################################################################
DOC>#######################################################################
DOC>   The following statement will cause an "ORA-01403: no data found"
DOC>   error if we're not in a PDB.
DOC>   This script is intended to be run right after plugin of a PDB,
DOC>   while inside the PDB.
DOC>#######################################################################
DOC>#######################################################################
DOC>#
SQL>
SQL> VARIABLE cdbname VARCHAR2(128)
SQL> VARIABLE pdbname VARCHAR2(128)
SQL> BEGIN
  2    SELECT sys_context('USERENV', 'CDB_NAME')
  3      INTO :cdbname
  4      FROM dual
  5      WHERE sys_context('USERENV', 'CDB_NAME') is not null;
  6    SELECT sys_context('USERENV', 'CON_NAME')
  7      INTO :pdbname
  8      FROM dual
  9      WHERE sys_context('USERENV', 'CON_NAME') <> 'CDB$ROOT';
 10  END;
 11  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
SQL>
SQL> @@?/rdbms/admin/loc_to_common0.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/loc_to_common0.sql /main/9 2018/07/25 13:49:55 surman Exp $
SQL> Rem
SQL> Rem loc_to_common0.sql
SQL> Rem
SQL> Rem Copyright (c) 2015, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      loc_to_common0.sql - <one-line expansion of the name>
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      <short description of component this file declares/defines>
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      <other useful comments, qualifications, etc.>
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common0.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common0.sql
SQL> Rem    SQL_PHASE: PDB
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE:
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
SQL> Rem    surman      03/13/18 - 27464252: Generic phase
SQL> Rem    vsampeng    11/23/17 - Bug 27158226: case sensitive PDB name
SQL> Rem    thbaby      04/21/17 - Bug 25940936: set _enable_view_pdb
SQL> Rem    sankejai    01/22/16 - 16076261: session parameters scoped to container
SQL> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
SQL> Rem    pyam        09/22/15 - 20959267: check for version mismatch
SQL> Rem    pyam        07/15/15 - Created
SQL> Rem
SQL>
SQL> SET ECHO ON
SQL> SET FEEDBACK 1
SQL> SET NUMWIDTH 10
SQL> SET LINESIZE 80
SQL> SET TRIMSPOOL ON
SQL> SET TAB OFF
SQL> SET PAGESIZE 100
SQL>
SQL> COLUMN pdbname NEW_VALUE pdbname
SQL> COLUMN pdbid NEW_VALUE pdbid
SQL>
SQL>
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.01
SQL> select :pdbname pdbname from dual;

PDBNAME
--------------------------------------------------------------------------------
PADAAN

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> select TO_CHAR(con_id) pdbid from v$pdbs where name='&pdbname';

PDBID
----------------------------------------
4

1 row selected.

Elapsed: 00:00:00.01
SQL>
SQL> -- save pluggable database open mode
SQL> -- Bug 27158226:This transaction encloses the pdb name with in the double quotes
SQL> --    to make the pdb name case sensitive one.
SQL> --    This is an extension of fix 25663931.
SQL> COLUMN open_state_col NEW_VALUE open_sql;
SQL> COLUMN restricted_col NEW_VALUE restricted_state;
SQL> SELECT decode(open_mode,
  2                'READ ONLY', 'ALTER PLUGGABLE DATABASE "&pdbname" OPEN READ ONLY',
  3                'READ WRITE', 'ALTER PLUGGABLE DATABASE "&pdbname" OPEN',
  4                'MIGRATE', 'ALTER PLUGGABLE DATABASE "&pdbname" OPEN UPGRADE', '')
  5           open_state_col,
  6         decode(restricted, 'YES', 'RESTRICTED', '')
  7           restricted_col
  8         from v$pdbs where name='&pdbname';

OPEN_STATE_COL                                   RESTRICTED
------------------------------------------------ ----------


1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> alter session set container=CDB$ROOT;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- if pdb was already closed, don't exit on error
SQL> WHENEVER SQLERROR CONTINUE;
SQL> alter pluggable database "&pdbname" close immediate instances=all;
alter pluggable database "PADAAN" close immediate instances=all
*
ERROR at line 1:
ORA-65020: pluggable database PADAAN already closed


Elapsed: 00:00:00.05
SQL> WHENEVER SQLERROR EXIT;
SQL>
SQL> alter pluggable database "&pdbname" open upgrade;

Pluggable database altered.

Elapsed: 00:00:01.38
SQL>
SQL> -- check that PDB and CDB versions match
SQL> SELECT TO_NUMBER('VERSION MISMATCH') from sys.dual
  2   WHERE (select count(*) from pdb_alert$ where name='&pdbname' and cause#=65
  3                                            and status=1) > 0;

no rows selected

Elapsed: 00:00:00.00
SQL>
SQL> alter session set container = "&pdbname";

Session altered.

Elapsed: 00:00:00.02
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- initial setup before beginning the script
SQL> -- Bug 16076261: nls_length_semantics is not a parameter, so the value is not
SQL> -- lost after set container in further scripts.
SQL> alter session set NLS_LENGTH_SEMANTICS=BYTE;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL>
SQL> ---------------------------------------------------------------------------
SQL> -- PRE-SCRIPT CHECKS GO HERE:
SQL>
SQL> -- Check that we have no invalid (not upgraded) table data from
SQL> -- ALTERing Oracle-Maintained Types
SQL> DOC
DOC>#######################################################################
DOC>#######################################################################
DOC>
DOC>     The following statement will cause an "ORA-01722: invalid number"
DOC>     error, if the database contains invalid data as a result of type
DOC>     evolution which was performed without the data being converted.
DOC>
DOC>     To resolve this specific "ORA-01722: invalid number" error:
DOC>       Perform the data conversion (details below) in the pluggable database.
DOC>
DOC>     Please refer to Oracle Database Object-Relational Developer's Guide
DOC>     for more information about type evolution.
DOC>
DOC>     Data in columns of evolved Oracle-Maintained types must be converted
DOC>     before the database can be converted.
DOC>
DOC>     The following commands, run inside the PDB, will perform the data
DOC>     conversion for Oracle supplied tables:
DOC>
DOC>     @?/rdbms/admin/catuptabdata.sql
DOC>
DOC>     You should then confirm that any non-Oracle supplied tables that
DOC>     are dependent on Oracle-Maintained types are also converted.
DOC>     You should review the data and determine if it needs
DOC>     to be converted or removed.
DOC>
DOC>     To view the columns affected by type evolution, execute the
DOC>     following inside the PDB:
DOC>
DOC>     SELECT rpad(u.name,128) TABLENAME, rpad(o.name,128) OWNER,
DOC>            rpad(c.name,128) COLNAME
DOC>     FROM SYS.OBJ$ o, SYS.COL$ c, SYS.COLTYPE$ t, SYS.USER$ u
DOC>     WHERE BITAND(t.FLAGS, 256) = 256  -- UPGRADED = NO
DOC>       AND o.OBJ# = t.OBJ# AND c.OBJ# = t.OBJ# AND c.COL# = t.COL#
DOC>       AND t.INTCOL# = c.INTCOL#
DOC>       AND o.owner# = u.user#
DOC>       AND o.owner# NOT IN -- NOT a COMMON user
DOC>           (SELECT user# FROM sys.user$
DOC>            WHERE type#=1 and bitand(spare1, 256)= 256)
DOC>       AND t.OBJ# IN  -- A dependent of an Oracle-Maintained type
DOC>           (SELECT DISTINCT d_obj#
DOC>            FROM sys.dependency$
DOC>            START WITH p_obj# IN -- Oracle-Maintained types
DOC>                   (SELECT obj# from sys.obj$
DOC>                    WHERE type#=13 AND
DOC>                          bitand(flags, 4194304) = 4194304)
DOC>            CONNECT BY PRIOR d_obj# = p_obj#);
DOC>
DOC>     Once the data is confirmed, the following commands, run inside the PDB,
DOC>     will convert the data returned by the above query.
DOC>
DOC>     @?/rdbms/admin/utluptabdata.sql
DOC>
DOC>     Depending on the amount of data involved, converting the evolved type
DOC>     data can take a significant amount of time.
DOC>
DOC>     After this is complete, please rerun noncdb_to_pdb.sql.
DOC>
DOC>#######################################################################
DOC>#######################################################################
DOC>#
SQL>
SQL> set serveroutput on
SQL>
SQL> -- Adding invalid non-Oracle supplied objects to the utl_recomp_skip_list
SQL> -- to avoid compiling them during utl_recomp
SQL> INSERT INTO sys.utl_recomp_skip_list select obj# from obj$ where
  2    BITAND(flags, 4194304)=0 and status<>1;

1 row created.

Elapsed: 00:00:00.45
SQL> COMMIT;

Commit complete.

Elapsed: 00:00:00.03
SQL>
SQL> DECLARE
  2    do_abort boolean := false;
  3    t_null varchar2(1);
  4  BEGIN
  5
  6    -- check for Oracle-Maintained tables that are not UPGRADED
  7    BEGIN
  8      SELECT NULL INTO t_null
  9      FROM sys.coltype$ t, sys.obj$ o
 10      WHERE BITAND(t.flags, 256) = 256  -- UPGRADED = NO
 11        AND t.obj# = o.obj#
 12        AND o.owner# IN -- An Oracle-Supplied user
 13            (SELECT user# FROM sys.user$
 14             WHERE type#=1 and bitand(spare1, 256)= 256)
 15        AND rownum <=1;
 16      do_abort := TRUE;
 17      dbms_output.put_line('Oracle-Maintained tables need to be UPGRADED.');
 18    EXCEPTION
 19      WHEN NO_DATA_FOUND THEN NULL;
 20    END;
 21
 22    -- check for user tables dependent on Oracle-Maintained types
 23    -- that are not upgraded
 24    BEGIN
 25      SELECT NULL INTO t_null
 26      FROM sys.obj$ o, sys.coltype$ t
 27      WHERE BITAND(t.FLAGS, 256) = 256   -- UPGRADED = NO
 28        AND t.obj# = o.obj#
 29        AND o.owner# NOT IN -- Not an Oracle-Supplied user
 30            (SELECT user# FROM sys.user$
 31             WHERE type#=1 and bitand(spare1, 256)= 256)
 32        AND t.obj# IN
 33           (SELECT DISTINCT d_obj#
 34            FROM sys.dependency$
 35            START WITH p_obj# IN -- Oracle-Maintained types
 36                  (SELECT obj# from sys.obj$
 37                   WHERE type#=13 AND
 38                         bitand(flags, 4194304) = 4194304)
 39            CONNECT BY PRIOR d_obj# = p_obj#)
 40        AND rownum <=1;
 41      do_abort := TRUE;
 42      dbms_output.put_line('User tables dependent on Oracle-Maintained types');
 43      dbms_output.put_line('need to be UPGRADED.');
 44    EXCEPTION
 45      WHEN NO_DATA_FOUND THEN NULL;
 46    END;
 47
 48
 49    If do_abort THEN
 50      dbms_output.put_line ('Non-CDB conversion aborting.');
 51      dbms_output.put_line ('For instructions, look for ORA-01722 in this script.');
 52      dbms_output.put_line ('Please resolve these and rerun noncdb_to_pdb.sql.');
 53      RAISE INVALID_NUMBER;
 54    END IF;
 55  END;
 56  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:03.55
SQL>
SQL> -- END PRE-SCRIPT CHECKS
SQL> ---------------------------------------------------------------------------
SQL> -- NOTE: SHARING bits in OBJ$.FLAGS are:
SQL> -- - 65536  = MDL (Metadata Link)
SQL> -- - 131072 = DL (Data Link, formerly OBL)
SQL> -- - 4294967296 = EDL (Extended Data Link)
SQL> define mdl=65536
SQL> define dl=131072
SQL> define edl=4294967296
SQL> define sharing_bits=(&mdl+&dl+&edl)
SQL>
SQL> select count(*) from sys.obj$
  2  where bitand(flags, &sharing_bits) <> 0;

  COUNT(*)
----------
     64055

1 row selected.

Elapsed: 00:00:00.02
SQL>
SQL> -- 22465938: if obj$ common bits are already set for certain objects,
SQL> -- the noncdb_to_pdb conversion might fail to validate these objects.
SQL> -- When the first time noncdb_to_pdb.sql is run on a legacy database
SQL> -- which is plugged into the CDB, clear any such common bits.
SQL> declare
  2    to_pdb varchar2(128);
  3  begin
  4    select value$ into to_pdb from props$ where name = 'NONCDB_TO_PDB.SQL';
  5    if to_pdb = 'TRUE' then
  6      update sys.obj$
  7         set flags = flags - bitand(flags, &sharing_bits)
  8       where bitand(flags, &sharing_bits) <> 0;
  9      dbms_output.put_line('Common bits are cleared for ' ||
 10                           sql%rowcount || ' objects.');
 11      commit;
 12    else
 13      dbms_output.put_line('No need to clear common bits twice.');
 14    end if;
 15  exception
 16    when no_data_found then
 17      dbms_output.put_line('No need to clear common bits at all.');
 18  end;
 19  /
Common bits are cleared for 64055 objects.

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.55
SQL>
SQL> select count(*) from sys.obj$
  2  where bitand(flags, &sharing_bits) <> 0;

  COUNT(*)
----------
         0

1 row selected.

Elapsed: 00:00:00.02
SQL>
SQL> set serveroutput off;
SQL>
SQL> @@?/rdbms/admin/loc_to_common1.sql 1
SQL> Rem
SQL> Rem $Header: rdbms/admin/loc_to_common1.sql /st_rdbms_19/1 2018/12/08 04:29:56 nneeluru Exp $
SQL> Rem
SQL> Rem loc_to_common1.sql
SQL> Rem
SQL> Rem Copyright (c) 2014, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      loc_to_common1.sql - helper script for converting local to common
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Does the first set of operations needed to convert local to common.
SQL> Rem      Creates object-linked views.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      Called by noncdb_to_pdb.sql, apex_to_common.sql, pdb_to_apppdb.sql
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common1.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common1.sql
SQL> Rem    SQL_PHASE: PDB
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    nneeluru    12/06/18 - Backport nneeluru_bug-28745878 from main
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
SQL> Rem    surman      03/13/18 - 27464252: Generic phase
SQL> Rem    thbaby      04/21/17 - Bug 25940936: set _enable_view_pdb
SQL> Rem    pyam        01/05/17 - set/clear scriptparam separately per container
SQL> Rem    pyam        09/08/16 - RTI 19633354: remove duplicate set &scriptparam
SQL> Rem    akruglik    01/25/16 - (22132084): handle Extended Data links
SQL> Rem    sankejai    01/22/16 - 16076261: session parameters scoped to container
SQL> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
SQL> Rem    akruglik    11/24/15 - (21193922) App Common users are marked with both
SQL> Rem                           common and App-common bits
SQL> Rem    thbaby      09/02/15 - Bug 21774247: handle COMMON_DATA
SQL> Rem    juilin      09/01/15 - 21458522: rename syscontext FEDERATION_NAME
SQL> Rem    pyam        04/30/15 - 20989123: fix fed flags for user$
SQL> Rem    pyam        04/19/15 - 20795461: change to _application_script for
SQL> Rem                           pdb_to_apppdb
SQL> Rem    syetchin    04/06/15 - Fix for diffs in lrgdbconc0e3ee and
SQL> Rem                           lrgdbconc0e4ee by mjungerm
SQL> Rem    surman      01/08/15 - 19475031: Update SQL metadata
SQL> Rem    pyam        09/16/14 - Helper script #1 for converting local objects to
SQL> Rem                           common in a CDB environment.
SQL> Rem    pyam        09/16/14 - Created
SQL> Rem
SQL>
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
SQL> exec dbms_pdb.noncdb_to_pdb(&&1);

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14
SQL>
SQL> COLUMN rootcon NEW_VALUE rootcon
SQL> select decode(&&1, 5, SYS_CONTEXT('USERENV', 'APPLICATION_NAME'), 'CDB$ROOT')
  2         rootcon from dual;

ROOTCON
--------------------------------------------------------------------------------
CDB$ROOT

1 row selected.

Elapsed: 00:00:00.01
SQL>
SQL> COLUMN scriptparam NEW_VALUE scriptparam
SQL> select decode(&&1, 5, '"_APPLICATION_SCRIPT"', '"_ORACLE_SCRIPT"') scriptparam
  2    from dual;

SCRIPTPARAM
----------------
"_ORACLE_SCRIPT"

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> alter session set container=&rootcon;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- CDB Common Users/Roles have 128 (Common) set in user$.spare1 while App
SQL> -- Common Users/Roles have both 128 (Common) and 4096 (App Common) set.
SQL> -- If we are looking for App Common Users/Roles, CDB Common users/Roles get
SQL> -- skipped because we check whether user$.spare1 has both 128 and 4096 set,
SQL> -- but if we are interested in CDB Common Users/Roles, we need to restrict
SQL> -- ourselves to USER$ rows which have 128 but not 4096 set in spare1
SQL> COLUMN cmnusrflag NEW_VALUE cmnusrflag
SQL> select decode(&&1, 5, '4224', '128') cmnusrflag from dual;

CMN
---
128

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- if this is for federation conversion, only treat federation objects
SQL> -- as common
SQL> COLUMN fedobjflag NEW_VALUE fedobjflag
SQL> select decode(&&1, 5, '134217728', '0') fedobjflag from dual;

F
-
0

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- create temporary object-linked view to get list of objects marked as common
SQL> -- in CDB$ROOT
SQL> --
SQL> -- NOTE: SHARING bits in OBJ$.FLAGS are:
SQL> -- - 65536  = MDL (Metadata Link)
SQL> -- - 131072 = DL (Data Link, formerly OBL)
SQL> -- - 4294967296 = EDL (Extended Data Link)
SQL> define mdl=65536
SQL> define dl=131072
SQL> define edl=4294967296
SQL> define sharing_bits=(&mdl+&dl+&edl)
SQL>
SQL> create or replace view sys.cdb$common_root_objects&pdbid sharing=object as
  2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
  3         o.subname object_subname, o.signature object_sig,
  4         decode(bitand(o.flags, &sharing_bits),
  5                &edl+&mdl, 'EDL', &dl, 'DL', 'MDL') sharing
  6    from sys.obj$ o, sys.user$ u
  7   where o.owner#=u.user# and bitand(o.flags, &sharing_bits) <> 0
  8     and bitand(o.flags,&fedobjflag)=&fedobjflag;

View created.

Elapsed: 00:00:00.37
SQL>
SQL> -- Bug 21774247: Handle COMMON_DATA tables.
SQL> -- create temporary object-linked view to get list of tables marked as
SQL> -- common_data in Root
SQL> create or replace view sys.cdb$cdata_root_tables&pdbid sharing=object as
  2  select u.name owner, o.name object_name
  3    from sys.obj$ o, sys.user$ u, sys.tab$ t
  4   where o.owner#=u.user# and o.obj#=t.obj#
  5     and bitand(t.property, power(2,52))=power(2,52);

View created.

Elapsed: 00:00:00.03
SQL>
SQL> -- Bug 21774247: Handle COMMON_DATA views.
SQL> -- create temporary object-linked view to get list of views marked as
SQL> -- common_data in Root
SQL> create or replace view sys.cdb$cdata_root_views&pdbid sharing=object as
  2  select u.name owner, o.name object_name
  3    from sys.obj$ o, sys.user$ u, sys.view$ v
  4   where o.owner#=u.user# and o.obj#=v.obj#
  5     and bitand(v.property, power(2,52))=power(2,52);

View created.

Elapsed: 00:00:00.04
SQL>
SQL> create or replace view sys.cdb$cmn_root_types&pdbid sharing=object as
  2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
  3         o.subname object_subname, o.signature object_sig, t.hashcode hashcode,
  4         decode(bitand(o.flags, &sharing_bits),
  5                &edl+&mdl, 'EDL', &dl, 'DL', 'MDL') sharing
  6    from sys.obj$ o, sys.user$ u, sys.type$ t where
  7    o.type#=13 and o.oid$=t.tvoid and o.owner#=u.user# and
  8    bitand(o.flags, &sharing_bits) <> 0 and
  9    bitand(o.flags,&fedobjflag)=&fedobjflag;

View created.

Elapsed: 00:00:00.04
SQL>
SQL> -- object-linked view for list of common users
SQL> create or replace view sys.cdb$common_users&pdbid sharing=object as
  2  select name, type# from sys.user$
  3  where bitand(spare1,4224) = &cmnusrflag;

View created.

Elapsed: 00:00:00.01
SQL>
SQL> -- object-linked view for accessing dependency$
SQL> create or replace view sys.cdb$rootdeps&pdbid sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#;

View created.

Elapsed: 00:00:00.03
SQL>
SQL> -- TODO: update to include fed flags
SQL> -- object-linked view for accessing sysauth$: common system privileges
SQL> create or replace view sys.cdb$commonsysprivs&pdbid sharing=object as
  2  select u.name, s.privilege# from sys.user$ u, sys.sysauth$ s
  3  where s.grantee#=u.user# and bitand(s.option$,8)=8 and s.privilege#<0;

View created.

Elapsed: 00:00:00.02
SQL>
SQL> -- TODO: update to include fed flags
SQL> -- object-linked view for accessing sysauth$: common role grants
SQL> create or replace view sys.cdb$commonrolegrants&pdbid sharing=object as
  2  select u.name, r.name rolename from sys.user$ u, sys.sysauth$ s, sys.user$ r
  3  where s.grantee#=u.user# and bitand(s.option$,8)=8 and s.privilege#>0 and
  4  s.privilege#=r.user#;

View created.

Elapsed: 00:00:00.01
SQL>
SQL> -- TODO: update to include fed flags
SQL> -- object-linked view for accessing objauth$
SQL> create or replace view sys.cdb$commonobjprivs&pdbid sharing=object as
  2  select u.name, oa.privilege#, u2.name owner, o.name objname, oa.col#
  3  from sys.user$ u, sys.objauth$ oa, sys.obj$ o, sys.user$ u2
  4  where oa.grantee#=u.user# and bitand(oa.option$,8)=8
  5  and oa.obj#=o.obj# and o.owner#=u2.user#;

View created.

Elapsed: 00:00:00.08
SQL>
SQL> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- switch into PDB
SQL> alter session set container="&pdbname";

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
SQL> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- do java long identifier translation in the pdb if need be
SQL> -- which also does the translation in the root internally if need be;
SQL> -- this translation has to happen before the step with the comment
SQL> -- "mark objects in our PDB as common if they exist as common in ROOT"
SQL> -- in loc_to_common2.sql
SQL> declare junk varchar2(100);
  2  begin
  3  junk := dbms_java_test.funcall('-lid_translate_all', ' ');
  4  exception when others then null;
  5  end;
  6  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.10
SQL>
SQL> create or replace view sys.cdb$common_root_objects&pdbid sharing=object as
  2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
  3         o.subname object_subname, o.signature object_sig,
  4         decode(bitand(o.flags, &sharing_bits),
  5                &edl+&mdl, 'EDL', &dl, 'DL', 'MDL') sharing
  6    from sys.obj$ o, sys.user$ u
  7   where o.owner#=u.user# and bitand(o.flags, &sharing_bits) <> 0
  8     and bitand(o.flags,&fedobjflag)=&fedobjflag;

View created.

Elapsed: 00:00:00.17
SQL>
SQL> -- Bug 21774247: Handle COMMON_DATA tables.
SQL> -- create temporary object-linked view to get list of tables marked as
SQL> -- common_data in Root
SQL> create or replace view sys.cdb$cdata_root_tables&pdbid sharing=object as
  2  select u.name owner, o.name object_name
  3    from sys.obj$ o, sys.user$ u, sys.tab$ t
  4   where o.owner#=u.user# and o.obj#=t.obj#
  5     and bitand(t.property, power(2,52))=power(2,52);

View created.

Elapsed: 00:00:00.02
SQL>
SQL> -- Bug 21774247: Handle COMMON_DATA views.
SQL> -- create temporary object-linked view to get list of views marked as
SQL> -- common_data in Root
SQL> create or replace view sys.cdb$cdata_root_views&pdbid sharing=object as
  2  select u.name owner, o.name object_name
  3    from sys.obj$ o, sys.user$ u, sys.view$ v
  4   where o.owner#=u.user# and o.obj#=v.obj#
  5     and bitand(v.property, power(2,52))=power(2,52);

View created.

Elapsed: 00:00:00.03
SQL>
SQL> create or replace view sys.cdb$cmn_root_types&pdbid sharing=object as
  2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
  3         o.subname object_subname, o.signature object_sig, t.hashcode hashcode,
  4         decode(bitand(o.flags, &sharing_bits),
  5                &edl+&mdl, 'EDL', &dl, 'DL', 'MDL') sharing
  6    from sys.obj$ o, sys.user$ u, sys.type$ t where
  7    o.type#=13 and o.oid$=t.tvoid and o.owner#=u.user# and
  8    bitand(o.flags, &sharing_bits) <> 0 and
  9    bitand(o.flags,&fedobjflag)=&fedobjflag;

View created.

Elapsed: 00:00:00.05
SQL>
SQL> -- object-linked view for list of common users
SQL> create or replace view sys.cdb$common_users&pdbid sharing=object as
  2  select name, type# from sys.user$
  3  where bitand(spare1,4224) = &cmnusrflag;

View created.

Elapsed: 00:00:00.01
SQL>
SQL> -- object-linked view for accessing dependency$
SQL> create or replace view sys.cdb$rootdeps&pdbid sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#;

View created.

Elapsed: 00:00:00.07
SQL>
SQL> -- TODO: update to include fed flags
SQL> -- object-linked view for accessing sysauth$: common system privileges
SQL> create or replace view sys.cdb$commonsysprivs&pdbid sharing=object as
  2  select u.name, s.privilege# from sys.user$ u, sys.sysauth$ s
  3  where s.grantee#=u.user# and bitand(s.option$,8)=8 and s.privilege#<0;

View created.

Elapsed: 00:00:00.02
SQL>
SQL> -- TODO: update to include fed flags
SQL> -- object-linked view for accessing sysauth$: common role grants
SQL> create or replace view sys.cdb$commonrolegrants&pdbid sharing=object as
  2  select u.name, r.name rolename from sys.user$ u, sys.sysauth$ s, sys.user$ r
  3  where s.grantee#=u.user# and bitand(s.option$,8)=8 and s.privilege#>0 and
  4  s.privilege#=r.user#;

View created.

Elapsed: 00:00:00.01
SQL>
SQL> -- TODO: update to include fed flags
SQL> -- object-linked view for accessing objauth$
SQL> create or replace view sys.cdb$commonobjprivs&pdbid sharing=object as
  2  select u.name, oa.privilege#, u2.name owner, o.name objname, oa.col#
  3  from sys.user$ u, sys.objauth$ oa, sys.obj$ o, sys.user$ u2
  4  where oa.grantee#=u.user# and bitand(oa.option$,8)=8
  5  and oa.obj#=o.obj# and o.owner#=u2.user#;

View created.

Elapsed: 00:00:00.03
SQL>
SQL> create or replace view sys.cdb$objects&pdbid sharing=none as
  2  select u.name owner, o.name object_name, o.signature object_sig,
  3         o.namespace nsp, o.subname object_subname, o.obj# object_id,
  4         o.type# object_type, o.flags flags
  5    from sys.obj$ o, sys.user$ u
  6    where o.owner#=u.user#;

View created.

Elapsed: 00:00:00.03
SQL>
SQL> create or replace view sys.cdb$types&pdbid sharing=none as
  2  select u.name owner, o.name object_name, o.signature object_sig,
  3         o.namespace nsp, o.subname object_subname, o.obj# object_id,
  4         o.type# object_type, o.flags flags, t.hashcode hashcode
  5    from sys.obj$ o, sys.user$ u, sys.type$ t
  6    where o.owner#=u.user# and o.type#=13 and o.oid$=t.tvoid;

View created.

Elapsed: 00:00:00.02
SQL>
SQL>
SQL> create or replace view sys.cdb$tables&pdbid sharing=none as
  2  select * from sys.cdb$objects&pdbid where object_type=2;

View created.

Elapsed: 00:00:00.01
SQL>
SQL> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL>
SQL> -- 18478064:
SQL> -- In the case that this is run post-upgrade, we should reenable indexes that
SQL> -- were disabled during upgrade. That way, ENABLED$INDEXES created below will
SQL> -- accurately reflect . This is necessary because indexes can be dropped
SQL> -- and recreated during upgrade, and enabled$indexes.objnum would be outdated.
SQL> -- In the non-upgrade case, this will be a no-op, because enabled$indexes
SQL> -- wouldn't exist
SQL> @@?/rdbms/admin/reenable_indexes.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/reenable_indexes.sql /main/6 2018/07/25 13:49:55 surman Exp $
SQL> Rem
SQL> Rem reenable_indexes.sql
SQL> Rem
SQL> Rem Copyright (c) 2014, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      reenable_indexes.sql - <one-line expansion of the name>
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      <short description of component this file declares/defines>
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      <other useful comments, qualifications, etc.>
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/reenable_indexes.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/reenable_indexes.sql
SQL> Rem    SQL_PHASE: REENABLE_INDEXES
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
SQL> Rem    sylin       01/30/15 - bug20422151 - longer identifier
SQL> Rem    surman      01/08/15 - 19475031: Update SQL metadata
SQL> Rem    pyam        04/03/14 - Reenable indexes based on sys.enabled$indexes
SQL> Rem                           (formerly in utlprp.sql)
SQL> Rem    pyam        04/03/14 - Created
SQL> Rem
SQL>
SQL> Rem
SQL> Rem Declare function local_enquote_name to pass FALSE
SQL> Rem into underlying dbms_assert.enquote_name function
SQL> Rem
SQL> CREATE OR REPLACE FUNCTION local_enquote_name (str varchar2)
  2   return varchar2 is
  3     begin
  4          return dbms_assert.enquote_name(str, FALSE);
  5     end local_enquote_name;
  6  /

Function created.

Elapsed: 00:00:00.37
SQL> Rem
SQL> Rem If sys.enabled$index table exists, then re-enable
SQL> Rem list of functional indexes that were enabled prior to upgrade
SQL> Rem The table sys.enabled$index table is created in catupstr.sql
SQL> Rem
SQL> SET serveroutput on
SQL> DECLARE
  2     TYPE tab_char IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;
  3     commands tab_char;
  4     p_null   CHAR(1);
  5     p_schemaname  dbms_id;
  6     p_indexname   dbms_id;
  7     rebuild_idx_msg BOOLEAN := FALSE;
  8     non_existent_index exception;
  9     recycle_bin_objs exception;
 10     cannot_change_obj exception;
 11     no_such_table  exception;
 12     pragma exception_init(non_existent_index, -1418);
 13     pragma exception_init(recycle_bin_objs, -38301);
 14     pragma exception_init(cannot_change_obj, -30552);
 15     pragma exception_init(no_such_table, -942);
 16     type cursor_t IS REF CURSOR;
 17     reg_cursor   cursor_t;
 18
 19  BEGIN
 20     -- Check for existence of the table marking disabled functional indices
 21
 22     SELECT NULL INTO p_null FROM DBA_OBJECTS
 23     WHERE owner = 'SYS' and object_name = 'ENABLED$INDEXES' and
 24              object_type = 'TABLE' and rownum <=1;
 25
 26        -- Select indices to be re-enabled
 27        EXECUTE IMMEDIATE q'+
 28           SELECT 'ALTER INDEX ' ||
 29                   local_enquote_name(e.schemaname) || '.' ||
 30                   local_enquote_name(e.indexname) || ' ENABLE'
 31              FROM   enabled$indexes e, ind$ i
 32              WHERE  e.objnum = i.obj# AND bitand(i.flags, 1024) != 0 AND
 33                     bitand(i.property, 16) != 0+'
 34        BULK COLLECT INTO commands;
 35
 36        IF (commands.count() > 0) THEN
 37           FOR i IN 1 .. commands.count() LOOP
 38              BEGIN
 39              EXECUTE IMMEDIATE commands(i);
 40              EXCEPTION
 41                 WHEN NON_EXISTENT_INDEX THEN NULL;
 42                 WHEN RECYCLE_BIN_OBJS THEN NULL;
 43                 WHEN CANNOT_CHANGE_OBJ THEN rebuild_idx_msg := TRUE;
 44              END;
 45           END LOOP;
 46        END IF;
 47
 48        -- Output any indexes in the table that could not be re-enabled
 49        -- due to ORA-30552 during ALTER INDEX...ENBLE command
 50
 51        IF  rebuild_idx_msg THEN
 52         BEGIN
 53           DBMS_OUTPUT.PUT_LINE
 54  ('The following indexes could not be re-enabled and may need to be rebuilt:');
 55
 56           OPEN reg_cursor FOR
 57               'SELECT e.schemaname, e.indexname
 58                FROM   enabled$indexes e, ind$ i
 59                WHERE  e.objnum = i.obj# AND bitand(i.flags, 1024) != 0';
 60
 61           LOOP
 62             FETCH reg_cursor INTO p_schemaname, p_indexname;
 63             EXIT WHEN reg_cursor%NOTFOUND;
 64             DBMS_OUTPUT.PUT_LINE
 65                ('.... INDEX ' || p_schemaname || '.' || p_indexname);
 66           END LOOP;
 67           CLOSE reg_cursor;
 68
 69         EXCEPTION
 70              WHEN NO_DATA_FOUND THEN CLOSE reg_cursor;
 71              WHEN NO_SUCH_TABLE THEN CLOSE reg_cursor;
 72              WHEN OTHERS THEN CLOSE reg_cursor; raise;
 73         END;
 74
 75        END IF;
 76
 77        EXECUTE IMMEDIATE 'DROP TABLE sys.enabled$indexes';
 78
 79     EXCEPTION
 80        WHEN NO_DATA_FOUND THEN NULL;
 81
 82  END;
 83  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
SQL>
SQL> DROP function local_enquote_name;

Function dropped.

Elapsed: 00:00:00.34
SQL> SET serveroutput off
SQL>
SQL>
SQL> -- record enabled indexes, so that if this script disables them implicitly
SQL> -- we can reenable them in the end
SQL> set serveroutput off
SQL>
SQL> CREATE TABLE sys.enabled$indexes sharing=none ( schemaname, indexname, objnum )
  2  AS select u.name, o1.name, i.obj# from user$ u, obj$ o1, obj$ o2, ind$ i
  3      where
  4          u.user# = o1.owner# and o1.type# = 1 and o1.obj# = i.obj#
  5         and bitand(i.property, 16)= 16 and bitand(i.flags, 1024)=0
  6         and i.bo# = o2.obj# and bitand(o2.flags, 2)=0;

Table created.

Elapsed: 00:00:01.10
SQL>
SQL> -- generate signatures for the common tables which don't have them
SQL> DECLARE
  2    cursor c is
  3      select r.owner, r.object_name
  4        from sys.cdb$common_root_objects&pdbid r, sys.cdb$tables&pdbid p
  5      where r.owner=p.owner and r.object_name=p.object_name
  6        and r.object_type=2 and p.object_sig is null
  7        and p.object_name not in ('OBJ$', 'USER$');
  8  BEGIN
  9    FOR tab in c
 10    LOOP
 11      BEGIN
 12        execute immediate 'ALTER TABLE ' || tab.owner || '."' ||
 13                          tab.object_name || '" UPGRADE';
 14      EXCEPTION
 15        WHEN OTHERS THEN
 16        BEGIN
 17          IF (sqlcode = -600 or sqlcode = -602 or sqlcode = -603) THEN
 18            raise;
 19          END IF;
 20        END;
 21      END;
 22    END LOOP;
 23    commit;
 24  END;
 25  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.79
SQL>
SQL> -- for each table whose signature doesn't match ROOT's, mark its PL/SQL
SQL> -- dependents for local MCode
SQL> DECLARE
  2    cursor c is
  3      select obj#
  4        from sys.obj$ o, sys.user$ u, sys.cdb$common_root_objects&pdbid ro
  5      where o.type# <> 4 and u.name=ro.owner and u.user#=o.owner#
  6        and o.name=ro.object_name and o.type#=ro.object_type and obj# in
  7        (select d_obj# from sys.dependency$ where p_obj# in
  8          (select p.object_id from sys.CDB$common_root_objects&pdbid r,
  9                                   sys.cdb$tables&pdbid p
 10           where r.owner=p.owner and r.object_name=p.object_name
 11             and r.object_type=2 and r.object_sig <> p.object_sig));
 12  BEGIN
 13    FOR obj in c
 14    LOOP
 15      update sys.obj$ set flags=flags+33554432-bitand(flags, 33554432)
 16                    where obj#=obj.obj#;
 17    END LOOP;
 18  END;
 19  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.17
SQL>
SQL> @@?/rdbms/admin/loc_to_common2.sql 0
SQL> Rem
SQL> Rem $Header: rdbms/admin/loc_to_common2.sql /st_rdbms_19/2 2020/08/05 11:39:15 sguruana Exp $
SQL> Rem
SQL> Rem loc_to_common2.sql
SQL> Rem
SQL> Rem Copyright (c) 2014, 2020, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      loc_to_common2.sql - helper script for converting local to common
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Does the second set of operations needed to convert local to common.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common2.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common2.sql
SQL> Rem    SQL_PHASE: PDB
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      Called by noncdb_to_pdb.sql, apex_to_common.sql, pdb_to_apppdb.sql
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    apfwkr      07/31/20 - Backport sguruana_bug-25809128 from main
SQL> Rem    sumkumar    12/20/18 - Bug 28964907: option$ column is null for non-cdb
SQL> Rem    sguruana    12/13/19 - Bug 25809128: avoid invalidating non-Oracle objs
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
SQL> Rem    kquinn      02/12/18 - Bug 25979661: handle bogus common users
SQL> Rem    surman      03/13/18 - 27464252: Generic phase
SQL> Rem    thbaby      04/21/17 - Bug 25940936: set _enable_view_pdb
SQL> Rem    thbaby      03/13/17 - Bug 25212689: exception handler for truncate
SQL> Rem    pyam        06/29/16 - 23184418: truncate data link tables in app pdb
SQL> Rem    tojhuan     03/22/16 - 22465938: keep common views in status INVALID
SQL> Rem    akruglik    01/15/16 - (22132084) replace COMMON_DATA with EXTENDED DATA
SQL> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
SQL> Rem    pyam        12/13/15 - LRG 18533922: dont invalidate
SQL> Rem                           STANDARD/DBMS_STANDARD
SQL> Rem    akruglik    11/24/15 - (21193922) App Common users are marked with both
SQL> Rem                           common and App-common bits
SQL> Rem    thbaby      09/02/15 - Bug 21774247: handle COMMON_DATA
SQL> Rem    pyam        06/24/15 - 21199445: mark converted objects as invalid
SQL> Rem    kquinn      05/18/15 - 21095719: improve performance
SQL> Rem    pyam        04/30/15 - 20989123: fix fed flags for user$
SQL> Rem    surman      01/08/15 - 19475031: Update SQL metadata
SQL> Rem    pyam        09/16/14 - Helper script #2 for converting local objects to
SQL> Rem                           common in a CDB environment.
SQL> Rem    pyam        09/16/14 - Created
SQL> Rem
SQL>
SQL> Rem fed == &&1;
SQL>
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- CDB Common Users/Roles have 128 (Common) set in user$.spare1 while App
SQL> -- Common Users/Roles have both 128 (Common) and 4096 (App Common) set.
SQL> COLUMN cmnusrflag NEW_VALUE cmnusrflag
SQL> select decode(&&1, 1, '4224', '128') cmnusrflag from dual;

CMN
---
128

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> COLUMN fedobjflag NEW_VALUE fedobjflag
SQL> select decode(&&1, 1, '134217728', '0') fedobjflag from dual;

F
-
0

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- 25979661: We might have some users already defined as a common user (e.g.
SQL> -- where we have built a traditional database from a shiphome but the shiphome
SQL> -- was originally built from a CB$ROOT). These users are currently APEX-related
SQL> -- so we need to clear the common user flag for this set of users at this
SQL> -- point.
SQL> update sys.user$ set spare1 = spare1 - &cmnusrflag
  2  where bitand(spare1, &cmnusrflag) = &cmnusrflag
  3  and bitand(spare1, 256) = 256                     -- KTSUCS1_ORCL = 0x100 = 256
  4  and name like 'APEX%';

0 rows updated.

Elapsed: 00:00:00.00
SQL>
SQL> -- 25979661: We also need to patch up the privilegess.
SQL> update sys.objauth$ set option$ = option$ +
  2         -- convert KZDOOCMNWGO (0x10) to KZDOOWGO (0x1)
  3         decode(bitand(option$, 16), 16,
  4            -16+decode(bitand(option$, 1), 1, 0, 1), 0) +
  5         -- convert KZDOOCMNWHO (0x20) to KZDOOWHO (0x2)
  6         decode(bitand(option$, 32), 32,
  7            -32 + decode(bitand(option$, 2), 2, 0, 2), 0) +
  8         -- clear KZDOOCMN (0x8) and KZDOO_NO_LOCAL (0x4)
  9         decode(bitand(option$, 8), 8, -8, 0) - 4
 10  where bitand(option$, 4) = 4 and
 11         (grantee# in (select user# from sys.user$ where name like 'APEX%') or
 12          grantor# in (select user# from sys.user$ where name like 'APEX%'));

0 rows updated.

Elapsed: 00:00:00.20
SQL>
SQL> update sys.objauth$ set option$ = option$ +
  2         -- clear KZDOOCMN (0x08), KZDOOCMNWGO (0x10) and KZDOOCMNWHO (0x20)
  3         decode(bitand(option$,  8),  8,  -8, 0) +
  4         decode(bitand(option$, 16), 16, -16, 0) +
  5         decode(bitand(option$, 32), 32, -32, 0)
  6  where bitand(option$, 4) != 4 and
  7         (grantee# in (select user# from sys.user$ where name like 'APEX%') or
  8          grantor# in (select user# from sys.user$ where name like 'APEX%'));

0 rows updated.

Elapsed: 00:00:00.01
SQL>
SQL> update sys.sysauth$ set option$ = option$ +
  2         -- convert KZDSYSCMNWAO (0x10) to KZDSYSWAO (0x1)
  3         decode(bitand(option$, 16), 16,
  4            -16+decode(bitand(option$, 1), 1, 0, 1), 0) +
  5         -- convert KZDSYSCMNWDO (0x20) to KZDSYSWDO (0x2)
  6         decode(bitand(option$, 32), 32,
  7            -32 + decode(bitand(option$, 2), 2, 0, 2), 0) +
  8         -- clear KZDSYSCMN (0x8) and KZDSYS_NO_LOCAL (0x4)
  9         decode(bitand(option$, 8), 8, -8, 0) - 4
 10  where bitand(option$, 4) = 4 and
 11         grantee# in (select user# from sys.user$ where name like 'APEX%');

0 rows updated.

Elapsed: 00:00:00.01
SQL>
SQL> update sys.sysauth$ set option$ = option$ +
  2         -- clear KZDSYSCMN (0x08), KZDSYSCMNWAO (0x10) and KZDSYSCMNWDO (0x20)
  3         decode(bitand(option$,  8),  8,  -8, 0) +
  4         decode(bitand(option$, 16), 16, -16, 0) +
  5         decode(bitand(option$, 32), 32, -32, 0)
  6  where bitand(option$, 4) != 4 and
  7         grantee# in (select user# from sys.user$ where name like 'APEX%');

0 rows updated.

Elapsed: 00:00:00.00
SQL>
SQL> -- mark users and roles in our PDB as common if they exist as common in ROOT
SQL> -- also compare the type# to ensure that we match users in PDB with users in
SQL> -- ROOT (and same for roles)
SQL> update sys.user$ a set a.spare1=a.spare1+&cmnusrflag where a.user# in (
  2    select p.user# from sys.cdb$common_users&pdbid r, sys.user$ p
  3    where r.name=p.name and r.type#=p.type# and bitand(p.spare1, 4224)=0);

0 rows updated.

Elapsed: 00:00:00.01
SQL>
SQL> -- TODO: fed
SQL> -- mark privileges in our PDB as common if they exist as common in ROOT
SQL> DECLARE
  2    cursor c is
  3      select s.grantee#, s.privilege#
  4        from sys.sysauth$ s, sys.user$ u, sys.cdb$commonsysprivs&pdbid r
  5       where u.user#=s.grantee# and u.name=r.name and s.privilege#=r.privilege#
  6             and (s.option$ is null or bitand(s.option$,8)=0);
  7  BEGIN
  8    FOR obj in c
  9    LOOP
 10      BEGIN
 11        update sys.sysauth$
 12         set option$=nvl(option$,0)+12+bitand(nvl(option$,0),3)*15
 13          where grantee#=obj.grantee# and privilege#=obj.privilege#;
 14      END;
 15    END LOOP;
 16    commit;
 17  END;
 18  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
SQL>
SQL>
SQL> -- TODO: fed
SQL> DECLARE
  2    cursor c is
  3      select s.grantee#, s.privilege#
  4        from sys.sysauth$ s, sys.user$ u, sys.cdb$commonrolegrants&pdbid r,
  5             sys.user$ ru
  6       where u.user#=s.grantee# and u.name=r.name and r.rolename=ru.name and
  7             s.privilege#=ru.user# and
  8             (s.option$ is null or bitand(s.option$,8)=0);
  9  BEGIN
 10    FOR obj in c
 11    LOOP
 12      BEGIN
 13        update sys.sysauth$
 14         set option$=nvl(option$,0)+12+bitand(nvl(option$,0),3)*15
 15          where grantee#=obj.grantee# and privilege#=obj.privilege#;
 16      END;
 17    END LOOP;
 18    commit;
 19  END;
 20  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
SQL>
SQL> -- TODO: fed
SQL> DECLARE
  2    cursor c is
  3      select oa.privilege#, oa.grantee#, oa.obj#, oa.col#
  4        from sys.objauth$ oa, sys.user$ u, sys.cdb$commonobjprivs&pdbid r,
  5             sys.obj$ o, sys.user$ ou
  6       where oa.privilege#=r.privilege# and oa.grantee#=u.user# and
  7             u.name=r.name and o.name=r.objname and oa.obj#=o.obj# and
  8             ou.name=r.owner and o.owner#=ou.user# and
  9             (oa.option$ is null or bitand(oa.option$,8)=0) and
 10             ((oa.col# is null and r.col# is null) or oa.col#=r.col#);
 11
 12  BEGIN
 13    FOR obj in c
 14    LOOP
 15      BEGIN
 16        IF (obj.col# is null) THEN
 17          update sys.objauth$ set option$=nvl(option$,0)+12+bitand(nvl(option$,0),3)*15
 18            where grantee#=obj.grantee# and privilege#=obj.privilege# and
 19                  obj#=obj.obj# and col# is null;
 20        ELSE
 21          update sys.objauth$ set option$=nvl(option$,0)+12+bitand(nvl(option$,0),3)*15
 22            where grantee#=obj.grantee# and privilege#=obj.privilege# and
 23                  obj#=obj.obj# and col# = obj.col#;
 24        END IF;
 25
 26      END;
 27    END LOOP;
 28    commit;
 29  END;
 30  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.55
SQL>
SQL> -- mark objects in our PDB as common if they exist as common in ROOT
SQL> -- mark them as invalid if they're of a type that can be invalid
SQL> -- LRG 18533922: refrain from invalidating STANDARD and DBMS_STANDARD
SQL> -- BUG 22465938: there is no guarantee that views are all validated
SQL> --     before noncdb_to_pdb/apex_to_common/pdb_to_apppdb, leading to
SQL> --     failure of follow-up loc_to_common steps. It is more robust to
SQL> --     keep their status INVALID (6) as we do on the other source objects.
SQL> --
SQL> -- NOTE: SHARING bits in OBJ$.FLAGS are:
SQL> -- - 65536  = MDL (Metadata Link)
SQL> -- - 131072 = DL (Data Link, formerly OBL)
SQL> -- - 4294967296 = EDL (Extended Data Link)
SQL> define mdl=65536
SQL> define dl=131072
SQL> define edl=4294967296
SQL> define sharing_bits=(&mdl+&dl+&edl)
SQL>
SQL> DECLARE
  2    cursor c is
  3      select p.object_id,
  4             p.flags-bitand(p.flags, &sharing_bits+&fedobjflag) flags,
  5             decode(r.sharing, 'MDL', &mdl, 'DL', &dl, &edl+&mdl) sharing_flag,
  6             case when p.object_type in (4, 7, 8, 9, 11, 12, 14, 22, 32, 33, 87)
  7                   and p.object_subname is null
  8                  then 6
  9                  else 1
 10             end new_status
 11        from sys.cdb$common_root_objects&pdbid r, sys.cdb$objects&pdbid p
 12      where r.owner=p.owner and r.object_name=p.object_name
 13        and r.object_type=p.object_type and r.object_type != 13 and r.nsp=p.nsp
 14        and (p.object_subname is null and r.object_subname is null
 15             or r.object_subname=p.object_subname)
 16        and decode(bitand(p.flags, &sharing_bits),
 17                   &edl+&mdl, 'EDL', &dl, 'DL', &mdl, 'MDL', 'NONE')
 18            <> r.sharing
 19        and not (r.owner='SYS' and
 20                 (r.object_name='STANDARD' or r.object_name='DBMS_STANDARD') and
 21                 (r.object_type in (9, 11)));
 22    cursor ctyp is
 23      select p.object_id,
 24             p.flags-bitand(p.flags, &sharing_bits+&fedobjflag) flags,
 25             decode(r.sharing, 'MDL', &mdl, 'DL', &dl, &edl+&mdl) sharing_flag
 26        from sys.cdb$cmn_root_types&pdbid r, sys.cdb$types&pdbid p
 27      where r.owner=p.owner and r.object_name=p.object_name
 28        and (p.object_subname is null and r.object_subname is null
 29             or r.object_subname=p.object_subname)
 30        and decode(bitand(p.flags, &sharing_bits),
 31                   &edl+&mdl, 'EDL', &dl, 'DL', &mdl, 'MDL', 'NONE')<>r.sharing
 32        and p.object_sig=r.object_sig and p.hashcode=r.hashcode;
 33  BEGIN
 34    FOR obj in c
 35    LOOP
 36      BEGIN
 37        update sys.obj$ set flags=(obj.flags + obj.sharing_flag + &fedobjflag),
 38                            status=obj.new_status
 39                      where obj#=obj.object_id and bitand(obj.flags, 4194304)<>0;
 40      END;
 41    END LOOP;
 42    FOR obj in ctyp
 43    LOOP
 44      BEGIN
 45        update sys.obj$ set flags=(obj.flags + obj.sharing_flag + &fedobjflag),
 46                            status=6
 47                      where obj#=obj.object_id and bitand(obj.flags, 4194304)<>0;
 48      END;
 49    END LOOP;
 50    commit;
 51  END;
 52  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:15.30
SQL>
SQL> -- BUG 23184418: truncate and drop index for datalink table.
SQL> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- make sure link flags are reloaded properly
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.06
SQL>
SQL> DECLARE
  2    cursor c is
  3      select p.object_id, p.object_type,
  4              '"' || p.owner || '"."' || p.object_name || '"' as name
  5      from sys.cdb$objects&pdbid p
  6      where p.object_type = 2 and bitand(p.flags, &dl) = &dl
  7       and  bitand(p.flags, 134217728)=&fedobjflag;
  8  BEGIN
  9    FOR obj in c
 10    LOOP
 11      BEGIN
 12        execute immediate 'TRUNCATE TABLE '|| obj.name;
 13      EXCEPTION WHEN OTHERS THEN NULL;
 14      END;
 15
 16      FOR ind IN
 17        (select '"'||u.name||'"."'||o.name||'"' as name
 18         from obj$ o, user$ u, (select unique i.obj# as idx_obj
 19                                from ind$ i
 20                                where bo# = obj.object_id and i.type# = 1 and
 21                                i.obj# not in (select nvl(enabled,0) from cdef$))
 22         where o.obj# = idx_obj and user# = owner#)
 23      LOOP
 24        BEGIN
 25          execute immediate 'DROP INDEX '|| ind.name;
 26        EXCEPTION WHEN OTHERS THEN NULL;
 27        END;
 28      END LOOP;
 29    END LOOP;
 30  END;
 31  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:03.90
SQL> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- Bug 21774247: Handle COMMON_DATA tables (this includes tables for which
SQL> -- COMMON_DATA was specified explicitly as well as EXTENDED DATA tables
SQL> -- (for which COMMON_DATA bit will be getting set for the time being.))
SQL> -- Retrieve all tables marked as COMMON_DATA in Root and mark them as
SQL> -- COMMON_DATA in PDB (if not already marked as COMMON_DATA).
SQL> DECLARE
  2    cursor c is
  3      select p.object_id
  4        from sys.cdb$cdata_root_tables&pdbid r, sys.cdb$objects&pdbid p
  5       where r.owner=p.owner and r.object_name=p.object_name;
  6  BEGIN
  7    FOR obj in c
  8      LOOP
  9        BEGIN
 10          update sys.tab$ t set t.property=(t.property + power(2,52))
 11                          where bitand(t.property, power(2,52)) = 0
 12                            and t.obj#=obj.object_id;
 13        END;
 14      END LOOP;
 15      commit;
 16  END;
 17  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
SQL>
SQL> -- Bug 21774247: Handle COMMON_DATA views (this includes views for which
SQL> -- COMMON_DATA was specified explicitly as well as EXTENDED DATA views
SQL> -- (for which COMMON_DATA bit will be getting set for the time being.))
SQL> -- Retrieve all views marked as COMMON_DATA in Root and mark them as
SQL> -- COMMON_DATA in PDB (if not already marked as COMMON_DATA).
SQL> DECLARE
  2    cursor c is
  3      select p.object_id
  4        from sys.cdb$cdata_root_views&pdbid r, sys.cdb$objects&pdbid p
  5       where r.owner=p.owner and r.object_name=p.object_name;
  6  BEGIN
  7    FOR obj in c
  8      LOOP
  9        BEGIN
 10          update sys.view$ v set v.property=(v.property + power(2,52))
 11                           where bitand(v.property, power(2,52)) = 0
 12                             and v.obj#=obj.object_id;
 13        END;
 14      END LOOP;
 15      commit;
 16  END;
 17  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.17
SQL>
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.08
SQL>
SQL>
SQL> -- Mark types created via xml schema registration as local. Only need to do
SQL> -- this for common types with system generated name.
SQL> DECLARE
  2    cursor c is
  3      select p.obj#, p.flags oldflags
  4      from sys.obj$ p, sys.dependency$ d, sys.obj$ o
  5      where p.type#=13 and d.p_obj#=p.obj# and d.d_obj#=o.obj# and o.type#=55
  6            and bitand(p.flags, &sharing_bits) != 0
  7            and ((regexp_instr(p.name, '[0-9]_T',1,1) != 0 and
  8                  regexp_instr(p.name, '[0-9]_T',1,1) = length(p.name)-2) or
  9                 (regexp_instr(p.name, '[0-9]_COLL',1,1) != 0 and
 10                  regexp_instr(p.name, '[0-9]_COLL',1,1) = length(p.name)-4));
 11  BEGIN
 12    FOR obj in c
 13    LOOP
 14      update sys.obj$ set flags=(obj.oldflags - bitand(obj.oldflags, &sharing_bits))
 15                    where obj#=obj.obj#;
 16    END LOOP;
 17  END;
 18  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.09
SQL>
SQL> -- As types with system generated name created via xml schema registration
SQL> -- are marked as local, mark default tables depending on those types as
SQL> -- local too, plus default tables with system generated table name.
SQL> -- Only need to do this for common tables.
SQL> DECLARE
  2    cursor c is
  3    with v as (select p.obj#, p.flags pflags
  4               from sys.obj$ p, sys.dependency$ d, sys.obj$ o
  5               where p.type#=13 and p.obj#=d.p_obj# and d.d_obj#=o.obj#
  6                     and o.type#=55)
  7    select distinct o1.obj#, o1.flags oldflags
  8    from v, sys.dependency$ d1, sys.obj$ o1
  9    where v.obj#=d1.p_obj# and d1.d_obj#=o1.obj# and o1.type#=2
 10          and bitand(o1.flags, &sharing_bits) != 0
 11          and ((bitand(pflags, &sharing_bits) = 0) or
 12               (regexp_instr(o1.name, '[0-9]_TAB',1,1) != 0 and
 13                regexp_instr(o1.name, '[0-9]_TAB',1,1) = length(o1.name)-3));
 14  BEGIN
 15    FOR obj in c
 16    LOOP
 17      BEGIN
 18        update sys.obj$ set flags=(obj.oldflags - bitand(obj.oldflags, &sharing_bits))
 19                      where obj#=obj.obj#;
 20      END;
 21    END LOOP;
 22  END;
 23  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14
SQL>
SQL> -- As default tables created via xml schema registration are marked as local,
SQL> -- mark all nested tables as local too if its parent table is local.
SQL> -- Only need to do this for common nested tables.
SQL> declare
  2    -- get local O-R xmltype parent table owned by common users
  3    cursor ortabq is
  4      select n.owner, n.parent_table_name
  5      from sys.obj$ o, dba_users u, dba_nested_tables n,
  6      ( select owner, table_name from dba_xml_tables
  7        where storage_type='OBJECT-RELATIONAL'
  8        union
  9        select owner, table_name from dba_xml_tab_cols
 10        where storage_type='OBJECT-RELATIONAL'
 11       ) t
 12      where n.owner = t.owner
 13            and n.parent_table_name = t.table_name
 14            and t.owner = u.username
 15            and u.common='YES'
 16            and u.user_id = o.owner#
 17            and o.name = t.table_name
 18            and bitand(o.flags, &sharing_bits) = 0
 19      order by n.owner, n.parent_table_name;
 20
 21    -- get the hierarchy of nested tables, given a parent table name and owner
 22    cursor ntq(oname varchar2, pname varchar2) is
 23      select n.owner, n.parent_table_name, n.table_name
 24      from dba_nested_tables n
 25      where n.owner=oname
 26      start with parent_table_name=pname
 27      connect by prior table_name=parent_table_name
 28      order by n.owner, n.parent_table_name, n.table_name;
 29
 30    -- get obj$ entries for the common nested tables, given its owner and name
 31    cursor c (owner_name varchar2, obj_name varchar2) is
 32      select o.obj#, o.flags oldflags
 33      from sys.obj$ o, dba_users u
 34      where o.owner#=u.user_id and u.username=owner_name and o.name=obj_name
 35            and bitand(o.flags, &sharing_bits) != 0;
 36  begin
 37    for rec in ortabq loop
 38      for ntrec in ntq(rec.owner, rec.parent_table_name) loop
 39        for obj in c(ntrec.owner, ntrec.table_name) loop
 40          begin
 41            update sys.obj$
 42               set flags=(obj.oldflags - bitand(obj.oldflags, &sharing_bits))
 43             where obj#=obj.obj#;
 44          end;
 45        end loop;
 46      end loop;
 47    end loop;
 48  end;
 49  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:02.71
SQL>
SQL> select to_char(sysdate, 'Dy DD-Mon-YYYY HH24:MI:SS') from dual;

TO_CHAR(SYSDATE,'DYDD-MON-YYYYHH24:MI:SS')
------------------------------------------
Tue 23-Feb-2021 12:56:03

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- get rid of idl_ub1$ rows for MDL java objects
SQL> delete from sys.idl_ub1$ where obj# in (select obj# from sys.obj$ where bitand(flags, 65536)=65536 and type# in (28,29,30,56));

40576 rows deleted.

Elapsed: 00:00:49.21
SQL> commit;

Commit complete.

Elapsed: 00:00:00.36
SQL>
SQL> -- normalize dependencies for MDL java objects (includes classes.bin objects)
SQL> delete from sys.dependency$ where d_obj# in (select obj# from sys.obj$ where bitand(flags,65536)=65536 and type# in (29,56));

75000 rows deleted.

Elapsed: 00:00:11.91
SQL>
SQL> insert into sys.dependency$ (select do.obj#,do.stime,order#,po.obj#,po.stime,do.owner#,property,d_attrs,d_reason from sys.obj$ do,sys.user$ du,sys.obj$ po,sys.user$ pu,sys.cdb$rootdeps&pdbid rd where du.user#=do.owner# and pu.user#=po.owner# and do.name=rd.name and du.name=owner and do.type#=d_type# and po.name=referenced_name and pu.name=referenced_owner and po.type#=p_type# and bitand(do.flags,65536)=65536 and do.type# in (29,56));

75000 rows created.

Elapsed: 00:00:07.14
SQL>
SQL> commit;

Commit complete.

Elapsed: 00:00:00.01
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.04
SQL>
SQL> select owner#, name from sys.obj$ where bitand(flags, 33554432)=33554432
  2    order by 1, 2;

no rows selected

Elapsed: 00:00:00.03
SQL>
SQL> -- pass in 1 to indicate that we need to invalidate STANDARD and DBMS_STANDARD
SQL> @@?/rdbms/admin/loc_to_common3.sql 1
SQL> Rem
SQL> Rem $Header: rdbms/admin/loc_to_common3.sql /st_rdbms_19/1 2020/08/05 11:39:16 sguruana Exp $
SQL> Rem
SQL> Rem loc_to_common3.sql
SQL> Rem
SQL> Rem Copyright (c) 2014, 2020, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      loc_to_common3.sql - helper script for converting local to common
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Does the third set of operations needed to convert local to common.
SQL> Rem      Does utlip + utlrp + related tasks.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      Called by noncdb_to_pdb.sql, apex_to_common.sql, pdb_to_apppdb.sql
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common3.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common3.sql
SQL> Rem    SQL_PHASE: PDB
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    sguruana    07/31/20 - backport of sguruana_bug-25809128 from main
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
SQL> Rem    surman      03/13/18 - 27464252: Generic phase
SQL> Rem    pyam        07/20/17 - Bug 26434999: turn off concurrent stats gathering
SQL> Rem    thbaby      04/22/17 - Bug 25940936: set _enable_view_pdb
SQL> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
SQL> Rem    pyam        12/13/15 - LRG 18533922: convert STANDARD/DBMS_STANDARD if
SQL> Rem                           necessary
SQL> Rem    pyam        10/21/15 - 12172090: move up marking valid of old type
SQL> Rem                           versions
SQL> Rem    vperiwal    03/26/15 - 20172151: add immediate instances = all for close
SQL> Rem    surman      01/08/15 - 19475031: Update SQL metadata
SQL> Rem    pyam        09/16/14 - Helper script #3 for converting local objects to
SQL> Rem                           common in a CDB environment.
SQL> Rem    pyam        09/16/14 - Created
SQL> Rem
SQL>
SQL> Rem invalidate_standard == &&1;
SQL>
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- if requested, invalidate STANDARD and DBMS_STANDARD and mark them common
SQL> update obj$ set status=6, flags=flags-bitand(flags,196608)+65536
  2   where &&1=1 and name in ('STANDARD', 'DBMS_STANDARD');

4 rows updated.

Elapsed: 00:00:00.02
SQL> commit;

Commit complete.

Elapsed: 00:00:00.02
SQL>
SQL> @@?/rdbms/admin/utlip
SQL> Rem
SQL> Rem $Header: rdbms/admin/utlip.sql
SQL> Rem
SQL> Rem utlip.sql
SQL> Rem
SQL> Rem Copyright (c) 1998, 2020, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem   NAME
SQL> Rem     utlip.sql - UTiLity script to Invalidate Pl/sql
SQL> Rem
SQL> Rem   DESCRIPTION
SQL> Rem
SQL> Rem     *WARNING*   *WARNING*  *WARNING*  *WARNING*  *WARNING*  *WARNING*
SQL> Rem
SQL> Rem     Do not run this script directly.
SQL> Rem
SQL> Rem     utlip.sql is automatically executed when required for database
SQL> Rem     upgrades.
SQL> Rem
SQL> Rem     Use utlirp.sql if you are looking to invalidate and recompile
SQL> Rem     PL/SQL for a 32-bit to 64-bit conversion. Use dbmsupgnv.sql
SQL> Rem     to convert all PL/SQL to NATIVE or dbmsupgin.sql to convert all
SQL> Rem     PL/SQL to INTERPRETED.
SQL> Rem
SQL> Rem     set serveroutput must be set to off before
SQL> Rem     invoking this script otherwise deadlocks
SQL> Rem     and internal errors may result.
SQL> Rem
SQL> Rem     *WARNING*   *WARNING*  *WARNING*  *WARNING*  *WARNING*  *WARNING*
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/utlip.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/utlip.sql
SQL> Rem    SQL_PHASE: UPGRADE
SQL> Rem    SQL_STARTUP_MODE: UPGRADE
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: rdbms/admin/catupstr.sql
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem   MODIFIED   (MM/DD/YY)
SQL> Rem    apfwkr      07/31/20 - Backport sguruana_bug-25809128 from main
SQL> Rem    sguruana    12/13/19 - 25809128: use &andorclsupp in additional places
SQL> Rem    pyam        09/08/17 - 25837415: delete diana with negative version num
SQL> Rem    raeburns    03/09/17 - Bug 25616909: Use UPGRADE for SQL_PHASE
SQL> Rem    pyam        02/10/17 - Fwd merge 25125745: remove deletes
SQL> Rem    pyam        09/30/16 - 24711897: delete potential duplicate idl_* rows
SQL> Rem    jaeblee     06/13/16 - 23239870: force compilation of standard
SQL> Rem    pyam        12/22/15 - 21927236: update props$ checks to pdb_to_apppdb
SQL> Rem    pyam        06/11/14 - LRG 11949012: fix invalidation clause for
SQL> Rem                           noncdb_to_pdb.sql
SQL> Rem    pyam        05/22/14 - for ncdb-to-pdb conversion, invalidate not only
SQL> Rem                           plsql
SQL> Rem    pyam        04/17/14 - 18063022: now called from noncdb_to_pdb.sql.
SQL> Rem                           Invalidate only common objs if unconverted
SQL> Rem                           non-CDB
SQL> Rem    jerrede     11/08/12 - Document set serveroutput on deadlock issue
SQL> Rem                           Lrg 8473773
SQL> Rem    gviswana    05/02/07 - Add warning messages; revert view Diana delete
SQL> Rem    gviswana    06/10/06 - Delete Diana performance optimization
SQL> Rem    gviswana    06/06/06 - Delete 11.x Diana for fine-grain deps
SQL> Rem    ssubrama    12/30/05 - bug 4882839 invalidate dbms_standard dependents
SQL> Rem    gviswana    06/17/05 - Delete sequence Diana
SQL> Rem    weiwang     05/06/05 - invalidate rules engine objects
SQL> Rem    ciyer       07/24/04 - selectively invalidate views and synonyms
SQL> Rem    jmuller     02/12/04 - Fix bug 3432304: commit even if no rows deleted
SQL> Rem    gviswana    08/28/03 - 3103287: Remove Diana deletions for PL/SQL
SQL> Rem    jmallory    08/18/03 - Hardcode dbms_dbupgrade_subname
SQL> Rem    gviswana    06/23/03 - 2985184: Invalidate dependent views
SQL> Rem    kquinn      07/22/03 - 3009599: Handle remote dbms_standard case
SQL> Rem    jmallory    06/09/03 - Fix null checking
SQL> Rem    jmallory    03/31/03 - Exclude dbupgrade objects
SQL> Rem    gviswana    04/16/03 - Move system parameter handling to utlirp.sql
SQL> Rem    kmuthukk    02/03/03 - fix update performance
SQL> Rem    nfolkert    12/23/02 - invalidate summary objects
SQL> Rem    kmuthukk    10/22/02 - ncomp dlls in db
SQL> Rem    gviswana    10/28/02 - Deferred synonym translation
SQL> Rem    rdecker     11/09/01 - remove CREATE library code FOR bug 1952368
SQL> Rem    gviswana    08/17/01 - Break up IDL_ deletes to avoid blowing rollback
SQL> Rem    rburns      08/23/01 - bug 1950073 - add exit on error
SQL> Rem    rburns      08/24/01 - add plitblm
SQL> Rem    rburns      07/26/01 - invalidate index types and operators
SQL> Rem    rxgovind    04/30/01 - interim fix for bug-1747462
SQL> Rem    gviswana    10/19/00 - Disable system triggers for Standard recompile
SQL> Rem    sbalaram    06/01/00 - Add prvthssq.sql after resolving Bug 1292760
SQL> Rem    thoang      05/26/00 - Do not invalidate earlier type versions
SQL> Rem    jdavison    04/11/00 - Modify usage notes for 8.2 changes.
SQL> Rem    rshaikh     09/22/99 - quote library names
SQL> Rem    mjungerm    06/15/99 - add java shared data object type
SQL> Rem    rshaikh     02/12/99 - dont delete java idl objects
SQL> Rem    rshaikh     11/17/98 - remove obsolete comments
SQL> Rem    rshaikh     10/30/98 - add slash after last truncate stmt
SQL> Rem    abrik       10/01/98 - just truncate idl_*$ tables
SQL> Rem    rshaikh     10/14/98 - bug 491101: recreate libraries
SQL> Rem    ncramesh    08/04/98 - change for sqlplus
SQL> Rem    rshaikh     07/20/98 - add commits
SQL> Rem    usundara    06/03/98 - merge from 8.0.5
SQL> Rem    usundara    04/29/98 - creation (split from utlirp)
SQL> Rem                           Kannan Muthukkaruppan (kmuthukk) was the original
SQL> Rem                           author of this script.
SQL>
SQL> Rem ===========================================================================
SQL> Rem BEGIN utlip.sql
SQL> Rem ===========================================================================
SQL>
SQL> Rem Exit immediately if Any failure in this script
SQL> WHENEVER SQLERROR EXIT;
SQL>
SQL> -- If we are in the middle of converting a PDB, the initial objects we
SQL> -- invalidate should be limited to common objects
SQL> COLUMN andcommon NEW_VALUE andcommon
SQL> select decode(cnt, 0, '', 'and bitand(flags,196608)<>0') andcommon
  2    from (select count(*) cnt from props$
  3          where name in ('NONCDB_TO_PDB.SQL', 'PDB_TO_APPPDB.SQL')
  4            and value$='CONVERTING');

ANDCOMMON
---------------------------
and bitand(flags,196608)<>0

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- if invalidate should be limited to Oracle-supplied objects
SQL> COLUMN andorclsupp NEW_VALUE andorclsupp
SQL> select decode(cnt, 0, '', 'and bitand(flags,4194304)<>0') andorclsupp
  2    from (select count(*) cnt from props$
  3          where name='NONCDB_TO_PDB.SQL' and value$='CONVERTING');

ANDORCLSUPP
----------------------------
and bitand(flags,4194304)<>0

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- if invalidate should be limited to Application Container objects
SQL> COLUMN andapp NEW_VALUE andapp
SQL> select decode(cnt, 0, '', 'and bitand(flags,134217728)<>0') andapp
  2    from (select count(*) cnt from props$
  3          where name='PDB_TO_APPPDB.SQL' and value$='CONVERTING');

ANDAPP
------------------------------


1 row selected.

Elapsed: 00:00:00.01
SQL>
SQL> -- specify types to invalidate. If we're converting, invalidate beyond plsql
SQL> COLUMN typestoinv NEW_VALUE typestoinv
SQL> select decode(cnt, 0,
  2     '((type# in (7, 8, 9, 11, 12, 14, 22, 32, 33, 87)) or (type# = 13 and subname is null))',
  3     '((type# in (4,5,6,7,8,9,11,12,14,22,23,32,33)) or (type# = 13 and subname is null))')
  4         typestoinv
  5    from (select count(*) cnt from props$
  6          where name in ('NONCDB_TO_PDB.SQL', 'PDB_TO_APPPDB.SQL')
  7            and value$='CONVERTING');

TYPESTOINV
--------------------------------------------------------------------------------
((type# in (4,5,6,7,8,9,11,12,14,22,23,32,33)) or (type# = 13 and subname is nul
l))


1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- call standard and dbmsstdx if this is not for app container conversion
SQL> COLUMN standard NEW_VALUE standard
SQL> select decode(cnt, 0, 'standard', 'nothing') standard
  2    from (select count(*) cnt from props$
  3          where name='PDB_TO_APPPDB.SQL' and value$='CONVERTING');

STANDARD
--------
standard

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> COLUMN dbmsstdx NEW_VALUE dbmsstdx
SQL> select decode(cnt, 0, 'dbmsstdx', 'nothing') dbmsstdx
  2    from (select count(*) cnt from props$
  3          where name='PDB_TO_APPPDB.SQL' and value$='CONVERTING');

DBMSSTDX
--------
dbmsstdx

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- Step (I)
SQL> --
SQL> -- First we invalidate all stored PL/SQL units (procs, fns, pkgs,
SQL> -- types, triggers.)
SQL> --
SQL> --   The type# in the update statement below indicates the KGL
SQL> --   type of the object. They have the following interpretation:
SQL> --       7 - pl/sql stored procedure
SQL> --       8 - pl/sql stored function
SQL> --       9 - pl/sql pkg spec
SQL> --      11 - pl/sql pkg body
SQL> --      12 - trigger
SQL> --      13 - type spec
SQL> --      14 - type body
SQL> --      22 - library
SQL> --      32 - indextype
SQL> --      33 - operator
SQL> --
SQL> -- Earlier type versions do not need to be invalidated since all pgm
SQL> -- units reference latest type versions. There is no mechanisms to
SQL> -- recompile earlier type versions anyway. They must be kept valid so
SQL> -- we can get access to its TDO to handle image conversion from one type
SQL> -- version to another.
SQL> -- All earlier type versions has the version name stored in obj$.subname
SQL> -- and the latest type version always has a null subname. We use this
SQL> -- fact to invalidate only the latest type version.
SQL> update obj$ set status = 6
  2          where &typestoinv
  3          and ((subname is null) or (subname <> 'DBMS_DBUPGRADE_BABY'))
  4          and status not in (5,6)
  5          and linkname is null
  6          and not exists (select 1
  7                          from type$
  8                          where (bitand(properties, 16) = 16)
  9                          and toid = obj$.oid$) &andorclsupp &andapp
 10  /

11954 rows updated.

Elapsed: 00:00:04.55
SQL> commit
  2  /

Commit complete.

Elapsed: 00:00:00.40
SQL>
SQL> Rem Always invalidate MVs during upgrades/ downgrades
SQL> update obj$ set status = 5 where type# = 42 &andorclsupp;

0 rows updated.

Elapsed: 00:00:00.01
SQL> commit;

Commit complete.

Elapsed: 00:00:00.01
SQL>
SQL> UPDATE sys.obj$ SET status = 5
  2  where obj# in
  3    ((select obj# from obj$ where type# = 62 or type# = 46 or type# = 59)
  4     union all
  5     (select /*+ index (dependency$ i_dependency2) */
  6        d_obj# from dependency$
  7        connect by prior d_obj# = p_obj#
  8        start with p_obj# in
  9          (select obj# from obj$ where type# = 62 or type# = 46 or type# = 59)))
 10    &andcommon
 11  /

0 rows updated.

Elapsed: 00:00:00.04
SQL> commit
  2  /

Commit complete.

Elapsed: 00:00:00.00
SQL>
SQL> -- Invalidate all synonym dependents of dbms_standard. If not we will end up
SQL> -- with a timestamp mismatch between dependency  and obj
SQL>
SQL> update obj$ set status=6 where obj# in
  2  (select d_obj# from dependency$
  3   where p_obj# in (select obj# from obj$ where name='DBMS_STANDARD' and
  4                    type# in ( 9, 11) and owner#=0)
  5  ) and type#=5
  6  /

1 row updated.

Elapsed: 00:00:00.05
SQL> commit
  2  /

Commit complete.

Elapsed: 00:00:00.01
SQL>
SQL> alter system flush shared_pool
  2  /

System altered.

Elapsed: 00:00:00.07
SQL>
SQL> --
SQL> -- Step (II)
SQL> --
SQL> -- Delete Diana to force full recompile (rather than fast validation).
SQL> -- Diana deletion is accomplished by changing the version number to make
SQL> -- rows invisible.
SQL> -- bug 25837415: delete any existing DIANA with negative version. We can have
SQL> -- pre-existing DIANA with negative version when noncdb_to_pdb.sql has
SQL> -- previously been run.
SQL> --
SQL> delete from idl_ub1$ where part = 0 and version<=-184549376;

0 rows deleted.

Elapsed: 00:00:00.25
SQL> delete from idl_ub2$ where part = 0 and version<=-184549376;

0 rows deleted.

Elapsed: 00:00:00.08
SQL> delete from idl_sb4$ where part = 0 and version<=-184549376;

0 rows deleted.

Elapsed: 00:00:00.04
SQL> delete from idl_char$ where part = 0 and version<=-184549376;

0 rows deleted.

Elapsed: 00:00:00.01
SQL> commit;

Commit complete.

Elapsed: 00:00:00.00
SQL>
SQL> update idl_ub1$ set version = -version
  2   where part = 0 and version >= 184549376
  3     and obj# IN
  4         (select obj# from obj$ o where status in (5, 6) and
  5                 type# in (7, 8, 9, 11, 12, 13, 14, 22, 32, 33, 87));

6002 rows updated.

Elapsed: 00:00:03.06
SQL> update idl_ub2$ SET version = -version
  2   where part = 0 and version >= 184549376
  3     and obj# IN
  4         (select obj# from obj$ o where status in (5, 6) and
  5                 type# in (7, 8, 9, 11, 12, 13, 14, 22, 32, 33, 87));

12893 rows updated.

Elapsed: 00:00:02.15
SQL> update idl_sb4$ SET version = -version
  2   where part = 0 and version >= 184549376
  3     and obj# IN
  4         (select obj# from obj$ o where status in (5, 6) and
  5                 type# in (7, 8, 9, 11, 12, 13, 14, 22, 32, 33, 87));

12019 rows updated.

Elapsed: 00:00:01.76
SQL> update idl_char$ SET version = -version
  2   where part = 0 and version >= 184549376
  3     and obj# IN
  4         (select obj# from obj$ o where status in (5, 6) and
  5                 type# in (7, 8, 9, 11, 12, 13, 14, 22, 32, 33, 87));

6114 rows updated.

Elapsed: 00:00:01.02
SQL>
SQL> commit;

Commit complete.

Elapsed: 00:00:00.27
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.07
SQL>
SQL> -- Step (II)
SQL> --
SQL> -- Recreate package standard and dbms_standard. This is needed to execute
SQL> -- subsequent anonymous blocks
SQL> alter session set "_force_standard_compile"=TRUE;

Session altered.

Elapsed: 00:00:00.01
SQL> @@&standard
SQL> @@?/rdbms/admin/sqlsessstart.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/sqlsessstart.sql /main/3 2018/07/25 13:50:02 surman Exp $
SQL> Rem
SQL> Rem sqlsessstart.sql
SQL> Rem
SQL> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      sqlsessstart.sql - SQL session start
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Any commands which should be run at the start of all oracle
SQL> Rem      supplied scripts.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      See sqlsessend.sql for the corresponding end script.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessstart.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessstart.sql
SQL> Rem    SQL_PHASE: MISC
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    surman      03/08/13 - 16462837: Common start and end scripts
SQL> Rem    surman      03/08/13 - Created
SQL> Rem
SQL>
SQL> alter session set "_ORACLE_SCRIPT" = true;

Session altered.

Elapsed: 00:00:00.00
SQL> @@stdspec.sql
SQL> @@?/rdbms/admin/sqlsessstart.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/sqlsessstart.sql /main/3 2018/07/25 13:50:02 surman Exp $
SQL> Rem
SQL> Rem sqlsessstart.sql
SQL> Rem
SQL> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      sqlsessstart.sql - SQL session start
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Any commands which should be run at the start of all oracle
SQL> Rem      supplied scripts.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      See sqlsessend.sql for the corresponding end script.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessstart.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessstart.sql
SQL> Rem    SQL_PHASE: MISC
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    surman      03/08/13 - 16462837: Common start and end scripts
SQL> Rem    surman      03/08/13 - Created
SQL> Rem
SQL>
SQL> alter session set "_ORACLE_SCRIPT" = true;

Session altered.

Elapsed: 00:00:00.00
SQL> create or replace
  2  package STANDARD AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!
  3
  4    /********** Types and subtypes, do not reorder **********/
  5    type BOOLEAN is (FALSE, TRUE);
  6
  7    type DATE is DATE_BASE;
  8
  9    type NUMBER is NUMBER_BASE;
 10    subtype FLOAT is NUMBER; -- NUMBER(126)
 11    subtype REAL is FLOAT; -- FLOAT(63)
 12    subtype "DOUBLE PRECISION" is FLOAT;
 13    subtype INTEGER is NUMBER(38,0);
 14    subtype INT is INTEGER;
 15    subtype SMALLINT is NUMBER(38,0);
 16    subtype DECIMAL is NUMBER(38,0);
 17    subtype NUMERIC is DECIMAL;
 18    subtype DEC is DECIMAL;
 19
 20
 21    subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
 22    subtype NATURAL is BINARY_INTEGER range 0..2147483647;
 23    subtype NATURALN is NATURAL not null;
 24    subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
 25    subtype POSITIVEN is POSITIVE not null;
 26    subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions
 27
 28    type VARCHAR2 is NEW CHAR_BASE;
 29
 30    subtype VARCHAR is VARCHAR2;
 31    subtype STRING is VARCHAR2;
 32
 33    subtype LONG is VARCHAR2(32760);
 34
 35    subtype RAW is VARCHAR2;
 36    subtype "LONG RAW" is RAW(32760);
 37
 38    subtype ROWID is VARCHAR2(256);
 39
 40    -- Ansi fixed-length char
 41    -- Define synonyms for CHAR and CHARN.
 42    subtype CHAR is VARCHAR2;
 43    subtype CHARACTER is CHAR;
 44
 45    type MLSLABEL is new CHAR_BASE;
 46
 47    -- Large object data types.
 48    --  binary, character, binary file.
 49    type  BLOB is BLOB_BASE;
 50    type  CLOB is CLOB_BASE;
 51    type  BFILE is BFILE_BASE;
 52
 53    -- Verbose and NCHAR type names
 54    subtype "CHARACTER VARYING" is VARCHAR;
 55    subtype "CHAR VARYING" is VARCHAR;
 56    subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
 57    subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
 58    subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
 59    subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
 60    subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
 61    subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
 62    subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
 63    subtype "CHARACTER LARGE OBJECT" is CLOB;
 64    subtype "CHAR LARGE OBJECT" is CLOB;
 65    subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
 66    subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
 67    subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
 68    subtype "BINARY LARGE OBJECT" is BLOB;
 69
 70    subtype pls_integer is binary_integer;
 71
 72    type TIME is new DATE_BASE;
 73    type TIMESTAMP is new DATE_BASE;
 74    type "TIME WITH TIME ZONE" is new DATE_BASE;
 75    type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
 76    type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
 77    type "INTERVAL DAY TO SECOND" is new DATE_BASE;
 78
 79    SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
 80    SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
 81    SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
 82    SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
 83    SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
 84    SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);
 85
 86    TYPE UROWID IS NEW CHAR_BASE;
 87
 88    type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
 89    subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;
 90
 91    subtype BINARY_FLOAT is NUMBER;
 92    subtype BINARY_DOUBLE is NUMBER;
 93
 94    -- The following data types are generics, used specially within package
 95    -- STANDARD and some other Oracle packages.  They are protected against
 96    -- other use; sorry.  True generic types are not yet part of the language.
 97
 98    type "<ADT_1>" as object (dummy char(1));
 99    type "<RECORD_1>" is record (dummy char(1));
100    type "<TUPLE_1>" as object (dummy char(1));
101    type "<VARRAY_1>" is varray (1) of char(1);
102    type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
103    type "<TABLE_1>" is table of char(1);
104    type "<COLLECTION_1>" is table of char(1);
105    type "<REF_CURSOR_1>" is ref cursor;
106
107    -- This will actually match against a Q_TABLE
108    type "<TYPED_TABLE>" is table of  "<ADT_1>";
109    subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";
110
111    -- The following generic index table data types are used by the PL/SQL
112    -- compiler to materialize an array attribute at the runtime (for more
113    -- details about the array attributes, please see Bulk Binds document).
114    type " SYS$INT_V2TABLE" is table of integer index by binary_integer;
115
116    -- The following record type and the corresponding generic index table
117    -- data types are used by the PL/SQL compiler to materialize a table
118    -- at the runtime in order to record the exceptions raised during the
119    -- execution of FORALL bulk bind statement (for more details, please
120    -- see bulk binds extensions document in 8.2).
121    type " SYS$BULK_ERROR_RECORD" is
122            record (error_index pls_integer, error_code pls_integer);
123    type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
124                                 index by binary_integer;
125
126    /* Adding a generic weak ref cursor type */
127    type sys_refcursor is ref cursor;
128
129    /* the following data type is a generic for all opaque types */
130    type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
131      (static function dummy return number);
132
133    type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);
134
135    /********** Add new types or subtypes here **********/
136
137    -- Simple scalar types
138
139    subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
140    subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
141    subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;
142
143    /********** Predefined constants **********/
144
145    BINARY_FLOAT_NAN constant BINARY_FLOAT;
146    BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
147    BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
148    BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
149    BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
150    BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
151    BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
152    BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
153    BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
154    BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
155    BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
156    BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;
157
158    /********** Add new constants here **********/
159
160    /********** Predefined exceptions **********/
161
162    CURSOR_ALREADY_OPEN exception;
163      pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');
164
165    DUP_VAL_ON_INDEX exception;
166      pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');
167
168    TIMEOUT_ON_RESOURCE exception;
169      pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');
170
171    INVALID_CURSOR exception;
172      pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');
173
174    NOT_LOGGED_ON exception;
175      pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');
176
177    LOGIN_DENIED exception;
178      pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');
179
180    NO_DATA_FOUND exception;
181      pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);
182
183    ZERO_DIVIDE exception;
184      pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');
185
186    INVALID_NUMBER exception;
187      pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');
188
189    TOO_MANY_ROWS exception;
190      pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');
191
192    STORAGE_ERROR exception;
193      pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');
194
195    PROGRAM_ERROR exception;
196      pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');
197
198    VALUE_ERROR exception;
199      pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');
200
201    ACCESS_INTO_NULL exception;
202      pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');
203
204    COLLECTION_IS_NULL exception;
205      pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');
206
207    SUBSCRIPT_OUTSIDE_LIMIT exception;
208      pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');
209
210    SUBSCRIPT_BEYOND_COUNT exception;
211      pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');
212
213    -- exception for ref cursors
214    ROWTYPE_MISMATCH exception;
215    pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');
216
217    SYS_INVALID_ROWID  EXCEPTION;
218    PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');
219
220    -- The object instance i.e. SELF is null
221    SELF_IS_NULL exception;
222      pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');
223
224    CASE_NOT_FOUND exception;
225      pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');
226
227    -- Added for USERENV enhancement, bug 1622213.
228    USERENV_COMMITSCN_ERROR exception;
229      pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');
230
231    -- Parallel and pipelined support
232    NO_DATA_NEEDED exception;
233      pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
234    -- End of 8.2 parallel and pipelined support
235
236    /********** Add new exceptions here **********/
237
238    /********** Function, operators and procedures **********/
239
240    function "EXISTS" return BOOLEAN;
241      pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj
242
243    function GREATEST (pattern NUMBER) return NUMBER;
244      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
245    function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
246          return VARCHAR2 CHARACTER SET pattern%CHARSET;
247      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
248    function GREATEST (pattern DATE) return DATE;
249      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
250
251    function LEAST (pattern NUMBER) return NUMBER;
252      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
253    function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
254          return VARCHAR2 CHARACTER SET pattern%CHARSET;
255      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
256    function LEAST (pattern DATE) return DATE;
257      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
258
259    function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
260      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
261    function DECODE (expr NUMBER,
262                     pat NUMBER,
263                     res VARCHAR2 CHARACTER SET ANY_CS)
264          return VARCHAR2 CHARACTER SET res%CHARSET;
265      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
266    function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
267      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
268
269    function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
270                     pat VARCHAR2 CHARACTER SET expr%CHARSET,
271                     res NUMBER) return NUMBER;
272      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
273    function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
274                     pat VARCHAR2 CHARACTER SET expr%CHARSET,
275                     res VARCHAR2 CHARACTER SET ANY_CS)
276          return VARCHAR2 CHARACTER SET res%CHARSET;
277      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
278    function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
279                     pat VARCHAR2 CHARACTER SET expr%CHARSET,
280                     res DATE) return DATE;
281      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
282
283    function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
284      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
285    function DECODE (expr DATE,
286                     pat DATE,
287                     res VARCHAR2 CHARACTER SET ANY_CS)
288          return VARCHAR2 CHARACTER SET res%CHARSET;
289      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
290    function DECODE (expr DATE, pat DATE, res DATE) return DATE;
291      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
292
293    function SQLCODE return PLS_INTEGER;
294      pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE
295
296    function SQLERRM return varchar2;
297      pragma FIPSFLAG('SQLERRM', 1452);
298
299    function SQLERRM (code PLS_INTEGER) return varchar2;
300      pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
301      pragma FIPSFLAG('SQLERRM', 1452);
302
303    function LEVEL return NUMBER;
304
305    function ROWNUM return NUMBER;
306
307    function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
308      pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
309      pragma FIPSFLAG('=', 1450);
310    function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
311      pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
312      pragma FIPSFLAG('!=', 1450);
313    function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
314      pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
315      pragma FIPSFLAG('<', 1450);
316    function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
317      pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
318      pragma FIPSFLAG('<=', 1450);
319    function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
320      pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
321      pragma FIPSFLAG('>', 1450);
322    function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
323      pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
324      pragma FIPSFLAG('>=', 1450);
325
326    --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
327    --  operations will always be interpreted as 'and then' and 'or else'
328    --  when they occur in conditional statements.
329
330    function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
331      pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
332      pragma FIPSFLAG('XOR', 1450);
333
334    function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
335      pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT
336
337    function 'IS NULL' (B BOOLEAN) return BOOLEAN;
338      pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
339      pragma FIPSFLAG('IS NULL', 1450);
340
341    function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
342      pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
343      pragma FIPSFLAG('IS NOT NULL', 1450);
344
345    function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
346      pragma FIPSFLAG('NVL', 1450);
347
348    function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
349                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
350      pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
351      pragma FIPSFLAG('=', 1454);
352    function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
353                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
354      pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
355      pragma FIPSFLAG('!=', 1454);
356    function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
357                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
358      pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
359      pragma FIPSFLAG('<', 1454);
360    function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
361                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
362      pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
363      pragma FIPSFLAG('<=', 1454);
364    function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
365                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
366      pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
367      pragma FIPSFLAG('>', 1454);
368    function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
369                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
370      pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
371      pragma FIPSFLAG('>=', 1454);
372
373    function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
374                   RIGHT VARCHAR2 CHARACTER SET ANY_CS)
375          return VARCHAR2 CHARACTER SET LEFT%CHARSET;
376      pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
377      pragma FIPSFLAG('||', 1454);
378
379    function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
380                    RIGHT VARCHAR2 CHARACTER SET ANY_CS)
381          return VARCHAR2 CHARACTER SET LEFT%CHARSET;
382      pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
383      pragma FIPSFLAG(CONCAT, 1454);
384
385    function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
386      pragma FIPSFLAG('LENGTH', 1452);
387    -- In SUBSTR, LEN defaults to remainder of string
388    -- In substr and instr, a negative value of parameter POS means to
389    -- count from the right end of the string.
390    function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
391                    POS PLS_INTEGER,
392                    LEN PLS_INTEGER := 2147483647)
393          return VARCHAR2 CHARACTER SET STR1%CHARSET;
394      pragma FIPSFLAG('SUBSTR', 1452);
395
396    -- Find nth occurrence of str1 in str2 starting at pos
397    function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
398                   STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
399                   POS PLS_INTEGER := 1,
400                   NTH POSITIVE := 1) return PLS_INTEGER;
401      pragma FIPSFLAG('INSTR', 1452);
402
403    function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
404          return VARCHAR2 CHARACTER SET ch%CHARSET;
405      pragma FIPSFLAG('UPPER', 1452);
406    function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
407          return VARCHAR2 CHARACTER SET ch%CHARSET;
408      pragma FIPSFLAG('LOWER', 1452);
409    function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
410          return INTEGER; -- should be ASCII.CHRANGE
411      pragma FIPSFLAG('ASCII', 1452);
412    function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
413          return VARCHAR2 CHARACTER SET ch%CHARSET;
414      pragma FIPSFLAG('ASCIISTR', 1452);
415    function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
416          return NVARCHAR2;
417      pragma FIPSFLAG('UNISTR', 1452);
418    function CHR(n INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
419      pragma FIPSFLAG('CHR', 1452);
420    function " SYS$STANDARD_CHR"(n INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
421          return VARCHAR2 CHARACTER SET csn%CHARSET;
422      pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
423    function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
424          return VARCHAR2 CHARACTER SET ch%CHARSET;
425      pragma FIPSFLAG('INITCAP', 1452);
426    function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
427          return VARCHAR2 CHARACTER SET ch%CHARSET;
428      pragma FIPSFLAG('SOUNDEX', 1452);
429
430    function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
431                  LEN pls_integer,
432                  PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
433          return VARCHAR2 CHARACTER SET STR1%CHARSET;
434      pragma FIPSFLAG('LPAD', 1452);
435    function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
436                  LEN pls_integer)
437          return VARCHAR2 CHARACTER SET STR1%CHARSET;
438    pragma FIPSFLAG('LPAD', 1452);
439
440    function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
441                  LEN pls_integer,
442                  PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
443          return VARCHAR2 CHARACTER SET STR1%CHARSET;
444      pragma FIPSFLAG('RPAD', 1452);
445    function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
446                  LEN pls_integer)
447          return VARCHAR2 CHARACTER SET STR1%CHARSET;
448      pragma FIPSFLAG('RPAD', 1452);
449
450    function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
451                       SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
452                       DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
453          return VARCHAR2 CHARACTER SET STR1%CHARSET;
454      pragma FIPSFLAG('TRANSLATE', 1452);
455
456    function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
457                     OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
458                     NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
459          return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
460      pragma FIPSFLAG('REPLACE', 1452);
461
462    function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
463                   TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
464          return VARCHAR2 CHARACTER SET STR1%CHARSET;
465      pragma FIPSFLAG('LTRIM', 1452);
466    function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
467          return VARCHAR2 CHARACTER SET STR1%CHARSET;
468      pragma FIPSFLAG('LTRIM', 1452);
469
470    function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
471                   TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
472          return VARCHAR2 CHARACTER SET STR1%CHARSET;
473      pragma FIPSFLAG('RTRIM', 1452);
474    function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
475          return VARCHAR2 CHARACTER SET STR1%CHARSET;
476      pragma FIPSFLAG('RTRIM', 1452);
477
478    function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
479                     pat VARCHAR2 CHARACTER SET str%CHARSET)
480          return BOOLEAN;
481    function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
482                         pat VARCHAR2 CHARACTER SET str%CHARSET)
483          return BOOLEAN;
484    function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
485                     pat VARCHAR2 CHARACTER SET str%CHARSET,
486                     esc VARCHAR2 CHARACTER SET str%CHARSET)
487          return BOOLEAN;
488    function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
489                         pat VARCHAR2 CHARACTER SET str%CHARSET,
490                         esc VARCHAR2 CHARACTER SET str%CHARSET)
491          return BOOLEAN;
492    function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
493      pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
494    function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
495      pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL
496
497    function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
498                 s2 VARCHAR2 CHARACTER SET s1%CHARSET)
499          return VARCHAR2 CHARACTER SET s1%CHARSET;
500      pragma FIPSFLAG('NVL', 1452);
501
502
503    function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
504      pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
505    function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
506      pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
507      pragma FIPSFLAG('!=', 1452);
508    function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
509      pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
510    function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
511      pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
512    function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
513      pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
514    function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
515      pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE
516
517    function 'IS NULL' (n NUMBER) return BOOLEAN;
518      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
519    function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
520      pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL
521
522    function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
523      pragma FIPSFLAG('NVL', 1452);
524
525    function '+' (RIGHT NUMBER) return NUMBER;
526      pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
527    function '-' (RIGHT NUMBER) return NUMBER;
528      pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
529    function ABS(n NUMBER) return NUMBER;
530      pragma FIPSFLAG('ABS', 1452);
531
532    function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
533      pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
534    function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
535      pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
536    function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
537      pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
538    function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
539      pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV
540
541    function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
542      pragma FIPSFLAG('REM', 1452);
543    function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
544      pragma FIPSFLAG('MOD', 1452);
545
546    function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
547      pragma FIPSFLAG('**', 1452);
548
549    function FLOOR(n NUMBER) return NUMBER;
550      pragma FIPSFLAG('FLOOR', 1452);
551    function CEIL(n NUMBER) return NUMBER;
552      pragma FIPSFLAG('CEIL', 1452);
553    function SQRT(n NUMBER) return NUMBER;
554      pragma FIPSFLAG('SQRT', 1452);
555    function SIGN(n NUMBER) return SIGNTYPE;
556    pragma FIPSFLAG('SIGN', 1452);
557
558    function COS(N NUMBER) return NUMBER;
559      pragma FIPSFLAG('COS', 1452);
560    function SIN(N NUMBER) return NUMBER;
561      pragma FIPSFLAG('SIN', 1452);
562    function TAN(N NUMBER) return NUMBER;
563      pragma FIPSFLAG('TAN', 1452);
564    function COSH(N NUMBER) return NUMBER;
565      pragma FIPSFLAG('COSH', 1452);
566    function SINH(N NUMBER) return NUMBER;
567      pragma FIPSFLAG('SINH', 1452);
568    function TANH(N NUMBER) return NUMBER;
569      pragma FIPSFLAG('TANH', 1452);
570
571    function EXP(N NUMBER) return NUMBER;
572    function LN(N NUMBER) return NUMBER;
573
574    function BITAND (LEFT pls_integer, RIGHT pls_integer)
575          return pls_integer;
576    function BITAND (LEFT number, RIGHT number)
577          return number;
578    function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
579
580    function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
581      pragma FIPSFLAG('TRUNC', 1452);
582
583    function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
584      pragma FIPSFLAG('ROUND', 1452);
585
586    function ROUND_TIES_TO_EVEN (N NUMBER, PLACES PLS_INTEGER := 0)
587          return NUMBER;
588
589    function POWER (n NUMBER, e NUMBER) return NUMBER;
590      pragma FIPSFLAG('POWER', 1452);
591
592    function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
593      pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
594      pragma FIPSFLAG('=', 1450);
595    function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
596      pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
597      pragma FIPSFLAG('!=', 1450);
598    function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
599      pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
600      pragma FIPSFLAG('<', 1450);
601    function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
602      pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
603      pragma FIPSFLAG('<=', 1450);
604    function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
605      pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
606      pragma FIPSFLAG('>', 1450);
607    function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
608      pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
609      pragma FIPSFLAG('>=', 1450);
610
611    function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
612      pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
613      pragma FIPSFLAG('+', 1450);
614    function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
615      pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
616      pragma FIPSFLAG('+', 1450);
617    function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
618      pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
619      pragma FIPSFLAG('-', 1450);
620    function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
621      pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
622      pragma FIPSFLAG('-', 1450);
623    function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
624      pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
625      pragma FIPSFLAG('-', 1450);
626
627    function LAST_DAY(RIGHT DATE) return DATE;
628      pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
629      pragma FIPSFLAG('LAST_DAY', 1450);
630    function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
631      pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
632      pragma FIPSFLAG('ADD_MONTHS', 1450);
633    function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
634      pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
635      pragma FIPSFLAG('ADD_MONTHS', 1450);
636
637    function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
638      pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
639      pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
640    function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
641      pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
642      pragma FIPSFLAG('NEXT_DAY', 1450);
643    function ROUND(RIGHT DATE) return DATE;
644      pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
645      pragma FIPSFLAG('ROUND', 1450);
646    function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
647      pragma FIPSFLAG('NEW_TIME', 1450);
648
649    function 'IS NULL' (d DATE) return BOOLEAN;
650      pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
651      pragma FIPSFLAG('IS NULL', 1450);
652    function 'IS NOT NULL' (d DATE) return BOOLEAN;
653      pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
654      pragma FIPSFLAG('IS NOT NULL', 1450);
655    function NVL (d1 DATE, d2 DATE) return DATE;
656      pragma FIPSFLAG('NVL', 1450);
657
658    function TRUNC(LEFT DATE) return DATE;
659      pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
660      pragma FIPSFLAG('TRUNC', 1450);
661    function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
662      pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
663      pragma FIPSFLAG('TRUNC', 1450);
664    function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
665      pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
666      pragma FIPSFLAG('ROUND', 1450);
667
668    function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
669      pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
670      pragma FIPSFLAG('TO_DATE', 1450);
671
672    function TO_DATE (LEFT VARCHAR2 character set any_cs,
673         RIGHT VARCHAR2 character set LEFT%charset) return DATE;
674      pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
675      pragma FIPSFLAG('TO_DATE', 1450);
676
677    function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
678      pragma FIPSFLAG('TO_DATE', 1450);
679
680    function TO_DATE(left varchar2 character set any_cs,
681                     format varchar2 character set LEFT%charset,
682                     parms varchar2 character set LEFT%charset) return date;
683
684    function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
685      pragma BUILTIN('TO_CHAR',14, 0, 2);
686
687    function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
688      pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
689      pragma FIPSFLAG('TO_CHAR', 1450);
690
691    function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
692      pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR
693
694    function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
695      pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK
696
697    function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
698      pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM
699
700    function TO_NUMBER(left varchar2 character set any_cs,
701          format varchar2 character set LEFT%charset)
702      return number;
703    function TO_NUMBER(left varchar2 character set any_cs,
704                       format varchar2 character set LEFT%charset,
705                       parms varchar2 character set LEFT%charset)
706      return number;
707
708    -- Define SQL predicates.  These don't gen code, so no body is needed.
709
710    -- PRIOR is WEIRD - For now, it will be treated as a function call.
711    -- Does the function only take a column name?  how about its use in
712    -- a predicate?
713    function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
714            return VARCHAR2 CHARACTER SET colname%CHARSET;
715        pragma FIPSFLAG('PRIOR', 1452);
716    function 'PRIOR'(colname NUMBER) return NUMBER;
717        pragma FIPSFLAG('PRIOR', 1452);
718    function 'PRIOR'(colname DATE) return DATE;
719        pragma FIPSFLAG('PRIOR', 1450);
720
721    -- Outer Join has same problem as PRIOR
722    function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
723            return VARCHAR2 CHARACTER SET colname%CHARSET;
724    function '(+)'(colname NUMBER) return NUMBER;
725    function '(+)'(colname DATE) return DATE;
726        pragma FIPSFLAG('(+)', 1450);
727
728    function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
729                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
730            return BOOLEAN;
731    function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
732        pragma FIPSFLAG('=ANY', 1450);
733    function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
734
735    function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
736                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
737            return BOOLEAN;
738    function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
739        pragma FIPSFLAG('!=ANY', 1450);
740    function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
741
742    function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
743                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
744            return BOOLEAN;
745    function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
746        pragma FIPSFLAG('<ANY', 1450);
747    function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
748
749    function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
750                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
751            return BOOLEAN;
752    function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
753        pragma FIPSFLAG('<=ANY', 1450);
754    function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
755
756    function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
757                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
758            return BOOLEAN;
759    function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
760        pragma FIPSFLAG('>ANY', 1450);
761    function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
762
763    function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
764                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
765            return BOOLEAN;
766    function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
767        pragma FIPSFLAG('>=ANY', 1450);
768    function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
769
770    function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
771                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
772            return BOOLEAN;
773    function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
774        pragma FIPSFLAG('=ALL', 1450);
775    function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
776
777    function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
778                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
779            return BOOLEAN;
780    function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
781        pragma FIPSFLAG('!=ALL', 1450);
782    function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
783
784    function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
785                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
786            return BOOLEAN;
787    function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
788        pragma FIPSFLAG('<ALL', 1450);
789    function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
790
791    function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
792                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
793            return BOOLEAN;
794    function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
795        pragma FIPSFLAG('<=ALL', 1450);
796    function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
797
798    function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
799                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
800            return BOOLEAN;
801    function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
802        pragma FIPSFLAG('>ALL', 1450);
803    function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
804
805    function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
806                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
807            return BOOLEAN;
808    function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
809        pragma FIPSFLAG('>=ALL', 1450);
810    function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
811
812    function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
813                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
814            return BOOLEAN;
815    function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
816        pragma FIPSFLAG('=SOME', 1450);
817    function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
818
819    function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
820                        RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
821            return BOOLEAN;
822    function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
823        pragma FIPSFLAG('!=SOME', 1450);
824    function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
825
826    function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
827                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
828            return BOOLEAN;
829    function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
830        pragma FIPSFLAG('<SOME', 1450);
831    function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
832
833    function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
834                        RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
835            return BOOLEAN;
836    function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
837        pragma FIPSFLAG('<=SOME', 1450);
838    function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
839
840    function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
841                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
842            return BOOLEAN;
843    function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
844        pragma FIPSFLAG('>SOME', 1450);
845    function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
846
847    function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
848                        RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
849            return BOOLEAN;
850    function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
851        pragma FIPSFLAG('>=SOME', 1450);
852    function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
853
854    -- SQL Transaction routines
855    procedure SET_TRANSACTION_USE(vc VARCHAR2);
856    procedure COMMIT;
857    procedure COMMIT_CM(vc VARCHAR2);
858    procedure ROLLBACK_NR;
859    procedure ROLLBACK_SV(Save_Point CHAR);
860    procedure SAVEPOINT(Save_Point CHAR);
861
862    function SYSDATE return DATE;
863      pragma FIPSFLAG('SYSDATE', 1452);
864
865    function UID return PLS_INTEGER;
866      pragma FIPSFLAG('UID', 1452);
867
868    function USER return VARCHAR2;
869
870    function USERENV (envstr VARCHAR2) return VARCHAR2;
871      pragma FIPSFLAG('USERENV', 1452);
872
873    -- ROWID: this dreadful identifier is supposed to represent a datatype
874    -- outside of SQL and and a pseudo-column (function, to us) when inside
875    -- a sql statement.  ADA data model doesn't allow for any
876    -- function X return X;
877    -- so we must special case this.  Yuk.  There's special-case code in ph2nre
878    -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
879    function "ROWID " return ROWID;
880      pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.
881
882    function NULLFN (str VARCHAR2) return RAW;
883      pragma builtin('NULLFN', 1, 0, 1);
884
885    function HEXTORAW (c VARCHAR2) return RAW;
886       pragma builtin('HEXTORAW', 1, 23, 1);
887
888    function RAWTOHEX (r RAW) return VARCHAR2;
889       pragma builtin('RAWTOHEX', 1, 23, 2);
890
891    function CHARTOROWID (str VARCHAR2) return ROWID;
892      pragma builtin('CHARTOROWID', 1, 0, 1);
893
894    function ROWIDTOCHAR (str ROWID) return VARCHAR2;
895      pragma builtin('ROWIDTOCHAR', 1, 0, 1);
896
897
898    -- Trusted*Oracle additions
899    Function ROWLABEL return MLSLABEL;                     -- pseudo column
900
901    Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
902      pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
903      pragma FIPSFLAG('TO_CHAR', 1450);
904
905    Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
906      pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
907      pragma FIPSFLAG('TO_LABEL', 1450);
908
909    Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
910      pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
911      pragma FIPSFLAG('TO_LABEL', 1450);
912
913    -- vararg routines - icds in stdbdy
914    Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
915      pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
916    Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
917      pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS
918
919    Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
920    Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
921    Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
922    Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
923    Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
924    Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
925    function 'IS NULL' (label MLSLABEL) return BOOLEAN;
926      pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
927    function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
928      pragma BUILTIN('IS NOT NULL', 0, 1, 50);
929
930    function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
931      pragma FIPSFLAG('NVL', 1452);
932
933    -- group functions
934    Function LUB (label MLSLABEL) return MLSLABEL;
935    Function GLB (label MLSLABEL) return MLSLABEL;
936
937    -- end of Trusted*Oracle additions
938
939
940    -- beginning of NLS routines
941
942    function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
943      pragma FIPSFLAG('NLSSORT', 1452);
944    function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
945      pragma FIPSFLAG('NLSSORT', 1452);
946    function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
947                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
948          return VARCHAR2 CHARACTER SET ch%CHARSET;
949      pragma FIPSFLAG('NLS_UPPER', 1452);
950    function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
951          return VARCHAR2 CHARACTER SET ch%CHARSET;
952      pragma FIPSFLAG('NLS_UPPER', 1452);
953    function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
954                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
955          return VARCHAR2 CHARACTER SET ch%CHARSET;
956      pragma FIPSFLAG('NLS_LOWER', 1452);
957    function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
958          return VARCHAR2 CHARACTER SET ch%CHARSET;
959      pragma FIPSFLAG('NLS_LOWER', 1452);
960    function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
961                         parms VARCHAR2 CHARACTER SET ch%CHARSET)
962          return VARCHAR2 CHARACTER SET ch%CHARSET;
963      pragma FIPSFLAG('NLS_INITCAP', 1452);
964    function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
965          return VARCHAR2 CHARACTER SET ch%CHARSET;
966      pragma FIPSFLAG('NLS_INITCAP', 1452);
967
968    function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
969      pragma FIPSFLAG('LENGTHB', 1452);
970    function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
971                     POS PLS_INTEGER,
972                     LEN PLS_INTEGER := 2147483647)
973          return VARCHAR2 CHARACTER SET STR1%CHARSET;
974      pragma FIPSFLAG('SUBSTRB', 1452);
975    function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
976                   STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
977                   POS PLS_INTEGER := 1,
978                   NTH POSITIVE := 1) return PLS_INTEGER;
979      pragma FIPSFLAG('INSTRB', 1452);
980
981    function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
982          return VARCHAR2 CHARACTER SET c%CHARSET;
983      pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
984    function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
985          return VARCHAR2 CHARACTER SET c%CHARSET;
986      pragma FIPSFLAG('TO_MULTI_BYTE', 1452);
987
988    -- Next two added for NLS 6/3/92 JEM.
989    function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
990    function TO_CHAR(left number, format varchar2, parms varchar2)
991      return varchar2;
992    function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
993    function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
994    function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
995      return PLS_INTEGER;
996
997    -- end of NLS routines
998
999    function CONVERT(src VARCHAR2 character set any_cs,
1000                     destcset VARCHAR2)
1001             return VARCHAR2 character set src%charset;
1002    function CONVERT(src VARCHAR2 character set any_cs,
1003                     destcset VARCHAR2,
1004                     srccset VARCHAR2)
1005            return VARCHAR2 character set src%charset;
1006
1007    function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
1008                                        csn VARCHAR2 CHARACTER SET ANY_CS)
1009            return VARCHAR2 CHARACTER SET csn%CHARSET;
1010       pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);
1011
1012    function VSIZE (e number ) return NUMBER;
1013        pragma builtin('VSIZE', 1, 0, 1);
1014    function VSIZE (e DATE) return NUMBER;
1015        pragma builtin('VSIZE', 1, 0, 1);
1016    function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
1017        pragma builtin('VSIZE', 1, 0, 1);
1018
1019
1020    -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
1021    function DUMP(e varchar2 character set any_cs,
1022                  df pls_integer := null,sp pls_integer := null,
1023                  len pls_integer := null) return VARCHAR2;
1024        pragma builtin('DUMP', 1, 0, 1);
1025
1026    function DUMP(e number,df pls_integer := null,sp pls_integer := null,
1027                    len pls_integer := null) return VARCHAR2;
1028        pragma builtin('DUMP', 1, 0, 1);
1029
1030    function DUMP(e date,df pls_integer := null,sp pls_integer := null,
1031                    len pls_integer := null) return VARCHAR2;
1032        pragma builtin('DUMP', 1, 0, 1);
1033
1034    --
1035    -- ACOS, ASIN, ATAN, ATAN2
1036    --   Inverse Trigonometric functions
1037    --   These functions return NULL if any of the inputs are NULL
1038    --
1039    function ACOS(N NUMBER) return NUMBER;
1040      pragma FIPSFLAG('ACOS', 1452);
1041
1042    function ASIN(N NUMBER) return NUMBER;
1043      pragma FIPSFLAG('ASIN', 1452);
1044
1045    function ATAN(N NUMBER) return NUMBER;
1046      pragma FIPSFLAG('ATAN', 1452);
1047
1048    function ATAN2(x NUMBER, y NUMBER) return NUMBER;
1049    pragma FIPSFLAG('ATAN2', 1452);
1050
1051    --#### This is the end of 7.3 Standard
1052
1053    -- LOB IS NULL
1054    function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
1055      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
1056    function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
1057      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
1058
1059    function 'IS NULL' (n BLOB) return BOOLEAN;
1060      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
1061    function 'IS NOT NULL' (n BLOB) return BOOLEAN;
1062      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
1063
1064    function 'IS NULL' (n BFILE) return BOOLEAN;
1065      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
1066    function 'IS NOT NULL' (n BFILE) return BOOLEAN;
1067      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
1068    -- end LOB IS NULL
1069
1070    --****************************************************************
1071    -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
1072    -- e.g.,                pragma builtin('whatever', 1, 1, 1)
1073    -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
1074    -- because they are not yet implemented by the backend.
1075
1076    function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1077      pragma BUILTIN('=', 1, 1, 1);
1078      pragma FIPSFLAG('=', 1450);
1079    function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1080      pragma BUILTIN('!=', 1, 1, 1);
1081      pragma FIPSFLAG('!=', 1450);
1082    function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1083      pragma BUILTIN('<', 1, 1, 1);
1084      pragma FIPSFLAG('<', 1450);
1085    function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1086      pragma BUILTIN('<=', 1, 1, 1);
1087      pragma FIPSFLAG('<=', 1450);
1088    function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1089      pragma BUILTIN('>', 1, 1, 1);
1090      pragma FIPSFLAG('>', 1450);
1091    function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1092      pragma BUILTIN('>=', 1, 1, 1);
1093      pragma FIPSFLAG('>=', 1450);
1094
1095    function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1096    function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1097    function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1098    function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1099    function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1100    function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1101    function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1102    function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1103    function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1104    function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1105    function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1106    function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1107    function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1108    function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1109    function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1110    function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1111    function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1112    function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
1113
1114    -- Outer Join
1115    function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
1116      pragma FIPSFLAG('(+)', 1450);
1117
1118    --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
1119    --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
1120    --    pragma BUILTIN('GREATEST', 1, 1, 1);
1121
1122    --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
1123    --    pragma BUILTIN('LEAST', 1, 1, 1);
1124
1125    function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
1126          return "<ADT_1>";
1127      pragma BUILTIN('DECODE', 1, 1, 1);
1128
1129    function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
1130      pragma BUILTIN('IS NULL', 0, 3, 0);
1131      pragma FIPSFLAG('IS NULL', 1450);
1132
1133    function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
1134      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
1135      pragma FIPSFLAG('IS NOT NULL', 1450);
1136
1137    function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
1138      pragma FIPSFLAG('NVL', 1450);
1139
1140    function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
1141      pragma BUILTIN('VALUE', 1, 1, 1);
1142      pragma FIPSFLAG('VALUE', 1450);
1143
1144    function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
1145      pragma BUILTIN('REF', 1, 1, 1);
1146      pragma FIPSFLAG('REF', 1450);
1147
1148    function DEREF (r REF "<ADT_1>") return "<ADT_1>";
1149      pragma BUILTIN('DEREF', 1, 1, 1);
1150      pragma FIPSFLAG('DEREF', 1450);
1151
1152    -- overloadings for REF ADT
1153
1154    function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
1155      pragma BUILTIN('IS NULL', 0, 3, 0);
1156      pragma FIPSFLAG('IS NULL', 1450);
1157
1158    function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
1159      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
1160      pragma FIPSFLAG('IS NOT NULL', 1450);
1161
1162    function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
1163      pragma BUILTIN('IS DANGLING', 1, 1, 1);
1164      pragma FIPSFLAG('IS DANGLING', 1450);
1165
1166    function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
1167      pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
1168      pragma FIPSFLAG('IS NOT DANGLING', 1450);
1169
1170    function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
1171      pragma FIPSFLAG('NVL', 1450);
1172
1173    function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
1174      pragma BUILTIN('=', 0, 3, 1);
1175      pragma FIPSFLAG('=', 1450);
1176
1177    function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
1178      pragma BUILTIN('!=', 0, 3, 2);
1179      pragma FIPSFLAG('!=', 1450);
1180
1181    --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
1182    --      return BOOLEAN;
1183    --    pragma BUILTIN('=', 1, 1, 1);
1184    --    pragma FIPSFLAG('=', 1450);
1185    --
1186    --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
1187    --      return BOOLEAN;
1188    --    pragma BUILTIN('!=', 1, 1, 1);
1189    --    pragma FIPSFLAG('!=', 1450);
1190    --
1191    --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
1192    --      return BOOLEAN;
1193    --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
1194    --      return BOOLEAN;
1195    --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
1196    --      return BOOLEAN;
1197    --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
1198    --      return BOOLEAN;
1199    --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
1200    --      return BOOLEAN;
1201    --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
1202    --      return BOOLEAN;
1203    --
1204    --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
1205    --                                        res "<COLLECTION_1>")
1206    --      return "<COLLECTION_1>";
1207    --    pragma BUILTIN('DECODE', 1, 1, 1);
1208
1209    -- Note that index-by tables are never NULL: this function will always
1210    -- return FALSE for them.
1211    function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
1212      pragma BUILTIN('IS NULL', 0, 3, 0);
1213      pragma FIPSFLAG('IS NULL', 1450);
1214
1215    -- Note that index-by tables are never NULL: this function will always
1216    -- return TRUE for them.
1217    function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
1218      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
1219      pragma FIPSFLAG('IS NOT NULL', 1450);
1220
1221    -- Note that index-by tables are never NULL: this function will always
1222    -- return B1 for them.
1223    function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
1224          return "<COLLECTION_1>";
1225      pragma FIPSFLAG('NVL', 1450);
1226
1227    function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
1228      pragma BUILTIN('IS NULL', 0, 3, 0);
1229      pragma FIPSFLAG('IS NULL', 1450);
1230
1231    function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
1232      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
1233      pragma FIPSFLAG('IS NOT NULL', 1450);
1234
1235    function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
1236          return "<REF_CURSOR_1>";
1237      pragma FIPSFLAG('NVL', 1450);
1238
1239    -- Note that associative arrays are never NULL: this function will always
1240    -- return FALSE.
1241    function 'IS NULL' (B "<ASSOC_ARRAY_1>") return BOOLEAN;
1242      pragma BUILTIN('IS NULL', 0, 3, 0);
1243      pragma FIPSFLAG('IS NULL', 1450);
1244
1245    -- Note that associative arrays are never NULL: this function will always
1246    -- return TRUE.
1247    function 'IS NOT NULL' (B "<ASSOC_ARRAY_1>") return BOOLEAN;
1248      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
1249      pragma FIPSFLAG('IS NOT NULL', 1450);
1250
1251    -- Note that associative arrays are never NULL: this function will always
1252    -- return B1.
1253    function NVL (B1 "<ASSOC_ARRAY_1>", B2 "<ASSOC_ARRAY_1>")
1254          return "<ASSOC_ARRAY_1>";
1255      pragma FIPSFLAG('NVL', 1450);
1256
1257    function EMPTY_CLOB return clob;
1258    function EMPTY_BLOB return blob;
1259
1260    function BFILENAME(directory varchar2,filename varchar2) return BFILE;
1261
1262    function "SYS$LOB_REPLICATION" (x in blob) return blob;
1263    function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
1264      return clob character set x%charset;
1265
1266    --#### This is the end of 8.0 Standard
1267
1268    --  + overloadings
1269
1270    function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
1271                 return TIMESTAMP_UNCONSTRAINED;
1272    function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1273                 return TIMESTAMP_UNCONSTRAINED;
1274
1275    function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
1276                 return TIMESTAMP_TZ_UNCONSTRAINED ;
1277    function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1278                 return TIMESTAMP_TZ_UNCONSTRAINED ;
1279
1280    function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1281                 return TIME_UNCONSTRAINED;
1282
1283    function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1284                 return TIME_TZ_UNCONSTRAINED;
1285
1286    function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
1287    function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
1288    function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
1289                 return TIMESTAMP_UNCONSTRAINED;
1290    function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
1291                 return TIMESTAMP_TZ_UNCONSTRAINED ;
1292    function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;
1293
1294    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
1295                 return TIMESTAMP_UNCONSTRAINED;
1296    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
1297                  return TIMESTAMP_TZ_UNCONSTRAINED ;
1298    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
1299                  return TIME_UNCONSTRAINED ;
1300    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
1301                  return TIME_TZ_UNCONSTRAINED ;
1302    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;
1303
1304    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1305                 return DSINTERVAL_UNCONSTRAINED ;
1306    function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
1307                 return YMINTERVAL_UNCONSTRAINED ;
1308
1309    -- begin subtract
1310    function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
1311                                       RIGHT TIMESTAMP_UNCONSTRAINED)
1312             return DSINTERVAL_UNCONSTRAINED ;
1313    function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
1314                                       RIGHT TIMESTAMP_UNCONSTRAINED)
1315             return YMINTERVAL_UNCONSTRAINED ;
1316    function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
1317                 return TIMESTAMP_UNCONSTRAINED;
1318    function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1319                 return TIMESTAMP_UNCONSTRAINED;
1320
1321    function " SYS$DSINTERVALSUBTRACT"
1322     (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
1323      return DSINTERVAL_UNCONSTRAINED ;
1324    function " SYS$YMINTERVALSUBTRACT"
1325     (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
1326      return YMINTERVAL_UNCONSTRAINED ;
1327    function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
1328      return TIMESTAMP_TZ_UNCONSTRAINED ;
1329    function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1330      return TIMESTAMP_TZ_UNCONSTRAINED ;
1331
1332    function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
1333                                        RIGHT TIME_UNCONSTRAINED)
1334       return DSINTERVAL_UNCONSTRAINED ;
1335    function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1336      return TIME_UNCONSTRAINED ;
1337    function " SYS$DSINTERVALSUBTRACT"
1338     (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
1339      return DSINTERVAL_UNCONSTRAINED ;
1340    function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1341      return TIME_TZ_UNCONSTRAINED ;
1342    function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
1343      return DSINTERVAL_UNCONSTRAINED ;
1344    function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
1345      return YMINTERVAL_UNCONSTRAINED ;
1346    function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
1347    function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;
1348
1349    function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
1350      return YMINTERVAL_UNCONSTRAINED ;
1351    function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
1352     return DSINTERVAL_UNCONSTRAINED ;
1353
1354    -- end subtract
1355
1356    -- other datetime operators
1357
1358    function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
1359      return YMINTERVAL_UNCONSTRAINED ;
1360    function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
1361      return DSINTERVAL_UNCONSTRAINED ;
1362
1363    function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
1364      return YMINTERVAL_UNCONSTRAINED ;
1365    function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
1366      return DSINTERVAL_UNCONSTRAINED ;
1367
1368    function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
1369      return YMINTERVAL_UNCONSTRAINED ;
1370    function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
1371      return DSINTERVAL_UNCONSTRAINED ;
1372
1373
1374    function current_date return date;
1375    function current_time return TIME_TZ_UNCONSTRAINED;
1376    function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;
1377
1378    function TO_TIME (RIGHT varchar2 character set any_cs) return
1379      time_unconstrained;
1380      pragma BUILTIN('TO_TIME', 0, 15, 1);
1381      function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
1382                             return TIMESTAMP_UNCONSTRAINED;
1383      pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
1384    function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
1385      return  TIME_TZ_UNCONSTRAINED;
1386      pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
1387    function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
1388      return  TIMESTAMP_TZ_UNCONSTRAINED;
1389      pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
1390    function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
1391      return  YMINTERVAL_UNCONSTRAINED;
1392      pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
1393    function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
1394      return  DSINTERVAL_UNCONSTRAINED;
1395      pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);
1396
1397    -- with nls args
1398    function TO_TIME(left varchar2 character set any_cs,
1399                     format varchar2 character set left%charset,
1400                     parms varchar2 character set left%charset)
1401      return TIME_UNCONSTRAINED;
1402    function TO_TIME(left varchar2 character set any_cs,
1403                     format varchar2 character set left%charset)
1404      return TIME_UNCONSTRAINED;
1405    function TO_TIMESTAMP(left varchar2 character set any_cs,
1406                          format varchar2 character set left%charset,
1407                          parms varchar2 character set left%charset)
1408      return TIMESTAMP_UNCONSTRAINED;
1409    function TO_TIMESTAMP(left varchar2 character set any_cs,
1410                          format varchar2 character set left%charset)
1411      return TIMESTAMP_UNCONSTRAINED;
1412    function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
1413                             format varchar2 character set left%charset,
1414                             parms varchar2 character set left%charset)
1415      return TIMESTAMP_TZ_UNCONSTRAINED;
1416    function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
1417                             format varchar2 character set left%charset)
1418      return TIMESTAMP_TZ_UNCONSTRAINED;
1419    function TO_TIME_TZ(left varchar2 character set any_cs,
1420                        format varchar2 character set left%charset,
1421                        parms varchar2 character set left%charset)
1422      return TIME_TZ_UNCONSTRAINED;
1423    function TO_TIME_TZ(left varchar2 character set any_cs,
1424                        format varchar2 character set left%charset)
1425      return TIME_TZ_UNCONSTRAINED;
1426    function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
1427                           parms varchar2 character set RIGHT%charset)
1428      return DSINTERVAL_UNCONSTRAINED;
1429
1430    function NUMTOYMINTERVAL(numerator number,
1431                             units varchar2 character set any_cs)
1432      return YMINTERVAL_UNCONSTRAINED;
1433    function NUMTODSINTERVAL(numerator number,
1434                             units varchar2 character set any_cs)
1435      return DSINTERVAL_UNCONSTRAINED;
1436
1437    function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
1438      pragma BUILTIN('=',0, 11, 1);
1439      pragma FIPSFLAG('=', 1450);
1440    function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
1441      pragma BUILTIN('!=',0, 11, 2);
1442      pragma FIPSFLAG('!=', 1450);
1443    function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
1444      pragma BUILTIN('<',0, 11, 3);
1445      pragma FIPSFLAG('<', 1450);
1446    function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
1447      pragma BUILTIN('<=',0, 11, 4);
1448      pragma FIPSFLAG('<=', 1450);
1449    function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
1450      pragma BUILTIN('>',0, 11, 5);
1451      pragma FIPSFLAG('>', 1450);
1452    function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
1453      pragma BUILTIN('>=',0, 11, 6);
1454      pragma FIPSFLAG('>=', 1450);
1455
1456    function 'IS NULL' (u UROWID) return BOOLEAN;
1457      pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
1458      pragma FIPSFLAG('IS NULL', 1450);
1459    function 'IS NOT NULL' (u UROWID) return BOOLEAN;
1460      pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
1461      pragma FIPSFLAG('IS NOT NULL', 1450);
1462
1463    function "UROWID " return UROWID;
1464      pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.
1465
1466    -- New built-in function SYS_GUID, returns globally unique id
1467    function SYS_GUID return RAW;
1468
1469    -- New built-in function SYS_CONTEXT
1470    function SYS_CONTEXT (namespace varchar2, attribute varchar2)
1471      return varchar2;
1472
1473    function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
1474      return VARCHAR2 CHARACTER SET v%CHARSET;
1475
1476    --#### This is the end of 8.1.5 Standard
1477
1478    -- SYS_CONTEXT now has an additional optional parameter
1479    function SYS_CONTEXT(namespace varchar2, attribute varchar2,
1480                         newoptional varchar2)
1481      return varchar2;
1482
1483    -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
1484    -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
1485    -- been added here as functions to avoid name capture issues.
1486    --
1487    -- Note that both CUBE and ROLLUP look like true vararg functions with
1488    -- *no* repeating pattern of formals - hence they are special cased in
1489    -- the overloading code.
1490    function CUBE return NUMBER;
1491    function ROLLUP return NUMBER;
1492
1493    -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
1494    -- in the GROUP BY clause. The type of the parameter to GROUPING can be
1495    -- any type that can appear in a GROUP BY list.
1496    function GROUPING(v VARCHAR2) return NUMBER;
1497    function GROUPING(a "<ADT_1>") return NUMBER;
1498
1499    -- This is for TRIM(x). No trim set.
1500    function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
1501      return VARCHAR2 CHARACTER SET v%CHARSET;
1502
1503    -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
1504    function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
1505                                   TRFLAG PLS_INTEGER)
1506      return VARCHAR2 CHARACTER SET STR1%CHARSET;
1507
1508    -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
1509    -- This one takes a trim set.
1510    function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
1511                                   TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
1512                                   TRFLAG PLS_INTEGER)
1513      return VARCHAR2 CHARACTER SET STR1%CHARSET;
1514
1515    --#### This is the end of the supported parts of 8.1.6 Standard
1516
1517    --## Support for ANSI datetime data types is under development.
1518    --## The following operations, as well as the related types and
1519    --## operations defined above in the 8.1.5 section, are not yet
1520    --## available for use and are still subject to change.
1521
1522    --- datetime equivalence
1523    function '='  (LEFT TIME_UNCONSTRAINED,
1524                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
1525    function '!=' (LEFT TIME_UNCONSTRAINED,
1526                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
1527    function '<'  (LEFT TIME_UNCONSTRAINED,
1528                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
1529    function '<=' (LEFT TIME_UNCONSTRAINED,
1530                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
1531    function '>'  (LEFT TIME_UNCONSTRAINED,
1532                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
1533    function '>=' (LEFT TIME_UNCONSTRAINED,
1534                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
1535
1536    function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
1537                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
1538    function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
1539                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
1540    function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
1541                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
1542    function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
1543                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
1544    function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
1545                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
1546    function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
1547                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
1548
1549    function '='  (LEFT TIME_TZ_UNCONSTRAINED,
1550                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
1551    function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
1552                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
1553    function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
1554                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
1555    function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
1556                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
1557    function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
1558                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
1559    function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
1560                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
1561
1562    function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
1563                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
1564    function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
1565                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
1566    function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
1567                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
1568    function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
1569                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
1570    function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
1571                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
1572    function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
1573                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
1574
1575    function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
1576                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
1577    function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
1578                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
1579    function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
1580                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
1581    function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
1582                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
1583    function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
1584                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
1585    function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
1586                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
1587
1588    function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
1589      pragma BUILTIN('TO_TIME', 0, 15, 13);
1590    function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
1591      pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
1592    function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
1593      return TIMESTAMP_UNCONSTRAINED;
1594      pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
1595    function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
1596      return TIMESTAMP_TZ_UNCONSTRAINED;
1597      pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);
1598
1599    function '-'
1600        (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
1601      return DSINTERVAL_UNCONSTRAINED;
1602    function '-'
1603        (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
1604      return DSINTERVAL_UNCONSTRAINED;
1605    function '-'
1606        (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
1607      return DSINTERVAL_UNCONSTRAINED;
1608    function '-'
1609        (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
1610      return DSINTERVAL_UNCONSTRAINED;
1611
1612    -- timezone functions
1613    function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
1614                              i varchar2) RETURN time_tz_unconstrained;
1615    function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
1616                              i varchar2) RETURN timestamp_tz_unconstrained;
1617    FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
1618    FUNCTION dbtimezone RETURN varchar2;
1619    FUNCTION sessiontimezone RETURN varchar2;
1620    FUNCTION localtimestamp RETURN timestamp_unconstrained;
1621    FUNCTION localtime RETURN time_unconstrained;
1622
1623    function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
1624      pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);
1625
1626    function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1627                 RIGHT yminterval_unconstrained)
1628      return TIMESTAMP_LTZ_UNCONSTRAINED;
1629    function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1630                 RIGHT dsinterval_unconstrained)
1631      return TIMESTAMP_LTZ_UNCONSTRAINED;
1632    function '+'(LEFT yminterval_unconstrained,
1633                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
1634      return TIMESTAMP_LTZ_UNCONSTRAINED ;
1635    function '+'(LEFT dsinterval_unconstrained,
1636                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
1637      return TIMESTAMP_LTZ_UNCONSTRAINED ;
1638
1639    function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1640                 RIGHT yminterval_unconstrained)
1641      return TIMESTAMP_LTZ_UNCONSTRAINED ;
1642    function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1643                 RIGHT dsinterval_unconstrained)
1644      return TIMESTAMP_LTZ_UNCONSTRAINED ;
1645
1646    function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1647                                       RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
1648      return dsinterval_unconstrained;
1649    function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1650                                       RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
1651      return yminterval_unconstrained;
1652
1653    function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1654                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
1655      return dsinterval_unconstrained;
1656
1657    function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
1658                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
1659    function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
1660                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
1661    function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
1662                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
1663    function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
1664                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
1665    function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
1666                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
1667    function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
1668                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
1669
1670    function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1671                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
1672    function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1673                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
1674    function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1675                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
1676    function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1677                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
1678    function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1679                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
1680    function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
1681                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
1682
1683    function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
1684      return YMINTERVAL_UNCONSTRAINED;
1685    function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
1686      return DSINTERVAL_UNCONSTRAINED;
1687    function SYS_LITERALTOTIME(numerator varchar2)
1688      return TIME_UNCONSTRAINED;
1689    function SYS_LITERALTOTZTIME(numerator varchar2)
1690      return TIME_TZ_UNCONSTRAINED;
1691    function SYS_LITERALTOTIMESTAMP(numerator varchar2)
1692      return TIMESTAMP_UNCONSTRAINED;
1693    function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
1694      return TIMESTAMP_TZ_UNCONSTRAINED;
1695    function SYS_LITERALTODATE(numerator varchar2) return DATE;
1696
1697
1698    -- Explicit conversions between date and datetime
1699    function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
1700      return TIMESTAMP_UNCONSTRAINED;
1701      pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);
1702
1703    function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
1704      pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);
1705
1706    function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
1707      return TIMESTAMP_TZ_UNCONSTRAINED;
1708      pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);
1709
1710    -- IS [NOT] NULL / NVL for datetime
1711    function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
1712    function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
1713    function NVL (b1 TIME_UNCONSTRAINED,
1714                  b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
1715
1716    function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
1717    function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
1718    function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
1719      return TIME_TZ_UNCONSTRAINED;
1720
1721    function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
1722    function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
1723    function NVL (b1 TIMESTAMP_UNCONSTRAINED,
1724                  b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;
1725
1726    function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
1727    function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
1728    function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
1729      return TIMESTAMP_TZ_UNCONSTRAINED;
1730
1731    function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
1732    function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
1733    function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
1734                  b2 TIMESTAMP_LTZ_UNCONSTRAINED)
1735      return TIMESTAMP_LTZ_UNCONSTRAINED;
1736
1737    function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
1738    function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
1739    function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
1740      return YMINTERVAL_UNCONSTRAINED;
1741
1742    function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
1743    function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
1744    function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
1745      return DSINTERVAL_UNCONSTRAINED;
1746
1747    function " SYS$EXTRACT_FROM"
1748                (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
1749    function " SYS$EXTRACT_FROM"
1750                (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
1751    function " SYS$EXTRACT_FROM"
1752                (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
1753    function " SYS$EXTRACT_FROM"
1754                (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
1755    function " SYS$EXTRACT_FROM"
1756                (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
1757    function " SYS$EXTRACT_FROM"
1758                (T DATE,FIELD VARCHAR2) return NUMBER;
1759    function " SYS$EXTRACT_FROM"
1760                (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
1761    function " SYS$EXTRACT_FROM"
1762                (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
1763
1764    -- ##########      8.2 LOB Built-in Functions       ######## --
1765
1766    -- LENGTH --
1767    function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
1768      pragma FIPSFLAG('LENGTH', 1452);
1769
1770    function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
1771      pragma FIPSFLAG('LENGTHB', 1452);
1772
1773    function LENGTH(bl BLOB) return integer;
1774      pragma FIPSFLAG('LENGTH', 1452);
1775
1776    function LENGTHB(bl BLOB) return integer;
1777      pragma FIPSFLAG('LENGTHB', 1452);
1778
1779    -- SUBSTR --
1780    function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
1781                    POS INTEGER,
1782                    LEN INTEGER := 18446744073709551615)
1783      return CLOB CHARACTER SET STR1%CHARSET;
1784      pragma FIPSFLAG('SUBSTR', 1452);
1785
1786    function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
1787                    POS INTEGER,
1788                    LEN INTEGER := 18446744073709551615)
1789      return CLOB CHARACTER SET STR1%CHARSET;
1790      pragma FIPSFLAG('SUBSTRB', 1452);
1791
1792    -- INSTR --
1793    function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
1794                   STR2 CLOB CHARACTER SET STR1%CHARSET,
1795                   POS INTEGER := 1,
1796                   NTH INTEGER := 1) return INTEGER;
1797      pragma FIPSFLAG('INSTR', 1452);
1798
1799    function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
1800                    STR2 CLOB CHARACTER SET STR1%CHARSET,
1801                    POS INTEGER := 1,
1802                    NTH INTEGER := 1) return INTEGER;
1803      pragma FIPSFLAG('INSTRB', 1452);
1804
1805    -- CONCAT --
1806    function '||' (LEFT CLOB CHARACTER SET ANY_CS,
1807                   RIGHT CLOB CHARACTER SET ANY_CS)
1808      return CLOB CHARACTER SET LEFT%CHARSET;
1809      pragma FIPSFLAG('||', 1454);
1810
1811    function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
1812                    RIGHT CLOB CHARACTER SET ANY_CS)
1813      return CLOB CHARACTER SET LEFT%CHARSET;
1814      pragma FIPSFLAG(CONCAT, 1454);
1815
1816    -- UPPER --
1817    function UPPER(ch CLOB CHARACTER SET ANY_CS)
1818      return CLOB CHARACTER SET ch%CHARSET;
1819      pragma FIPSFLAG('UPPER', 1452);
1820
1821    -- LOWER --
1822    function LOWER(ch CLOB CHARACTER SET ANY_CS)
1823      return CLOB CHARACTER SET ch%CHARSET;
1824      pragma FIPSFLAG('LOWER', 1452);
1825
1826    -- LPAD --
1827    function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
1828                  LEN integer,
1829                  PAD CLOB CHARACTER SET STR1%CHARSET)
1830      return CLOB CHARACTER SET STR1%CHARSET;
1831      pragma FIPSFLAG('LPAD', 1452);
1832
1833    function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
1834                  LEN integer)
1835      return CLOB CHARACTER SET STR1%CHARSET;
1836      pragma FIPSFLAG('LPAD', 1452);
1837
1838    -- RPAD --
1839    function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
1840                  LEN integer,
1841                  PAD CLOB CHARACTER SET STR1%CHARSET)
1842      return CLOB CHARACTER SET STR1%CHARSET;
1843      pragma FIPSFLAG('RPAD', 1452);
1844
1845    function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
1846                  LEN integer)
1847      return CLOB CHARACTER SET STR1%CHARSET;
1848      pragma FIPSFLAG('RPAD', 1452);
1849
1850    -- LTRIM --
1851    function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
1852                   TSET CLOB CHARACTER SET STR1%CHARSET)
1853      return CLOB CHARACTER SET STR1%CHARSET;
1854      pragma FIPSFLAG('LTRIM', 1452);
1855
1856    function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
1857      return CLOB CHARACTER SET STR1%CHARSET;
1858      pragma FIPSFLAG('LTRIM', 1452);
1859
1860    -- RTRIM --
1861    function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
1862                   TSET CLOB CHARACTER SET STR1%CHARSET)
1863      return CLOB CHARACTER SET STR1%CHARSET;
1864      pragma FIPSFLAG('RTRIM', 1452);
1865
1866    function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
1867      return CLOB CHARACTER SET STR1%CHARSET;
1868      pragma FIPSFLAG('RTRIM', 1452);
1869
1870    -- TRIM --
1871    function TRIM(v CLOB CHARACTER SET ANY_CS)
1872      return CLOB CHARACTER SET v%CHARSET;
1873
1874    -- This is for TRIM(x). No trim set.
1875    function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
1876      return CLOB CHARACTER SET v%CHARSET;
1877
1878    -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
1879    function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
1880                                 TRFLAG PLS_INTEGER)
1881      return CLOB CHARACTER SET STR1%CHARSET;
1882
1883    -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
1884    -- This one takes a trim set.
1885    function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
1886                                   TSET   CLOB CHARACTER SET STR1%CHARSET,
1887                                   TRFLAG PLS_INTEGER)
1888      return CLOB CHARACTER SET STR1%CHARSET;
1889
1890
1891    -- LIKE --
1892    function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
1893                     pat CLOB CHARACTER SET str%CHARSET)
1894      return BOOLEAN;
1895    function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
1896                         pat CLOB CHARACTER SET str%CHARSET)
1897      return BOOLEAN;
1898
1899    function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
1900                     pat CLOB CHARACTER SET str%CHARSET,
1901                     esc VARCHAR2 CHARACTER SET str%CHARSET)
1902      return BOOLEAN;
1903    function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
1904                         pat CLOB CHARACTER SET str%CHARSET,
1905                         esc VARCHAR2 CHARACTER SET str%CHARSET)
1906      return BOOLEAN;
1907
1908    -- NVL --
1909    function NVL(s1 CLOB CHARACTER SET ANY_CS,
1910                 s2 CLOB CHARACTER SET s1%CHARSET)
1911      return CLOB CHARACTER SET s1%CHARSET;
1912      pragma FIPSFLAG('NVL', 1452);
1913
1914    -- REPLACE --
1915    function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
1916                     OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
1917                     NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
1918      return CLOB CHARACTER SET SRCSTR%CHARSET;
1919      pragma FIPSFLAG('REPLACE', 1452);
1920
1921    -- LOB RELATIONAL OPERATORS --
1922
1923    Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
1924                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
1925    Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
1926                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
1927    Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
1928                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
1929    Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
1930                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
1931    Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
1932                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
1933    Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
1934                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
1935
1936    Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
1937                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
1938    Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
1939                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
1940    Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
1941                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
1942    Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
1943                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
1944    Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
1945                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
1946    Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
1947                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
1948
1949    Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
1950                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
1951    Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
1952                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
1953    Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
1954                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
1955    Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
1956                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
1957    Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
1958                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
1959    Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
1960                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
1961
1962    /* LOB-related conversion functions */
1963    function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
1964      pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
1965    function TO_BLOB(RIGHT RAW) return BLOB;
1966      pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
1967    function TO_RAW(RIGHT BLOB) return RAW;
1968      pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW
1969
1970    -- ####### end of 8.2 LOB Built-in Functions  ######## --
1971
1972    function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
1973    function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return BOOLEAN;
1974    function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return "<ADT_1>";
1975
1976    function COALESCE return VARCHAR2;
1977
1978    /* Daylight Saving Time Functions */
1979    FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
1980    FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
1981      RETURN timestamp_tz_unconstrained;
1982
1983    function " SYS$EXTRACT_STRING_FROM"
1984                (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
1985    function " SYS$EXTRACT_STRING_FROM"
1986                (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
1987    function " SYS$EXTRACT_STRING_FROM"
1988                (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
1989
1990    function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
1991                    STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
1992                    POS PLS_INTEGER := 1,
1993                    NTH POSITIVE := 1) return PLS_INTEGER;
1994      pragma FIPSFLAG('INSTR2', 1452);
1995
1996    function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
1997                    STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
1998                    POS PLS_INTEGER := 1,
1999                    NTH POSITIVE := 1) return PLS_INTEGER;
2000      pragma FIPSFLAG('INSTR4', 1452);
2001
2002    function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
2003                    STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
2004                    POS PLS_INTEGER := 1,
2005                    NTH POSITIVE := 1) return PLS_INTEGER;
2006      pragma FIPSFLAG('INSTRC', 1452);
2007
2008    function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
2009      pragma FIPSFLAG('LENGTH2', 1452);
2010
2011    function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
2012      pragma FIPSFLAG('LENGTH4', 1452);
2013
2014    function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
2015      pragma FIPSFLAG('LENGTHC', 1452);
2016
2017    function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
2018                      pat VARCHAR2 CHARACTER SET str%CHARSET)
2019      return BOOLEAN;
2020    function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
2021                          pat VARCHAR2 CHARACTER SET str%CHARSET)
2022      return BOOLEAN;
2023    function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
2024                      pat VARCHAR2 CHARACTER SET str%CHARSET,
2025                      esc VARCHAR2 CHARACTER SET str%CHARSET)
2026      return BOOLEAN;
2027    function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
2028                          pat VARCHAR2 CHARACTER SET str%CHARSET,
2029                          esc VARCHAR2 CHARACTER SET str%CHARSET)
2030      return BOOLEAN;
2031
2032    function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
2033                      pat VARCHAR2 CHARACTER SET str%CHARSET)
2034      return BOOLEAN;
2035    function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
2036                          pat VARCHAR2 CHARACTER SET str%CHARSET)
2037      return BOOLEAN;
2038    function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
2039                      pat VARCHAR2 CHARACTER SET str%CHARSET,
2040                      esc VARCHAR2 CHARACTER SET str%CHARSET)
2041      return BOOLEAN;
2042    function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
2043                          pat VARCHAR2 CHARACTER SET str%CHARSET,
2044                          esc VARCHAR2 CHARACTER SET str%CHARSET)
2045      return BOOLEAN;
2046
2047    function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
2048                      pat VARCHAR2 CHARACTER SET str%CHARSET)
2049      return BOOLEAN;
2050    function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
2051                          pat VARCHAR2 CHARACTER SET str%CHARSET)
2052      return BOOLEAN;
2053    function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
2054                      pat VARCHAR2 CHARACTER SET str%CHARSET,
2055                      esc VARCHAR2 CHARACTER SET str%CHARSET)
2056      return BOOLEAN;
2057    function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
2058                          pat VARCHAR2 CHARACTER SET str%CHARSET,
2059                          esc VARCHAR2 CHARACTER SET str%CHARSET)
2060      return BOOLEAN;
2061
2062    function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
2063                     POS PLS_INTEGER,
2064                     LEN PLS_INTEGER := 2147483647)
2065      return VARCHAR2 CHARACTER SET STR1%CHARSET;
2066      pragma FIPSFLAG('SUBSTR2', 1452);
2067
2068    function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
2069                     POS PLS_INTEGER,
2070                     LEN PLS_INTEGER := 2147483647)
2071      return VARCHAR2 CHARACTER SET STR1%CHARSET;
2072      pragma FIPSFLAG('SUBSTR4', 1452);
2073
2074    function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
2075                     POS PLS_INTEGER,
2076                     LEN PLS_INTEGER := 2147483647)
2077      return VARCHAR2 CHARACTER SET STR1%CHARSET;
2078      pragma FIPSFLAG('SUBSTRC', 1452);
2079
2080    /**** char <--> nchar conversion functions in Unicode project ********/
2081
2082    function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
2083      pragma BUILTIN('TO_NCHAR',14, 0, 2);
2084
2085    function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
2086    function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;
2087
2088    function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
2089      return NCLOB;
2090      pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
2091    /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
2092    function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
2093      return CLOB CHARACTER SET RIGHT%CHARSET;
2094      pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
2095
2096    /* Followings are the same builtin op codes as without N prefix functions,
2097     * implementation relys on impilcit conversion MCODEs
2098     */
2099    function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
2100      pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
2101      pragma FIPSFLAG('TO_NCHAR', 1450);
2102    function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
2103      pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR
2104
2105    function NHEXTORAW (c NVARCHAR2) return RAW;
2106      pragma builtin('NHEXTORAW', 1, 23, 1);
2107    function RAWTONHEX (r RAW) return NVARCHAR2;
2108      pragma builtin('RAWTONHEX', 1, 23, 2);
2109    function NCHARTOROWID (str NVARCHAR2) return ROWID;
2110      pragma builtin('NCHARTOROWID', 1, 0, 1);
2111    function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
2112      pragma builtin('ROWIDTONCHAR', 1, 0, 1);
2113
2114    function NCHR(n integer) return NVARCHAR2;
2115
2116    /* implemented by icd calls as the same as TO_CHAR */
2117    function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
2118      return nvarchar2;
2119    function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
2120      return nvarchar2;
2121
2122    /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
2123    function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;
2124
2125    /************ end of char <--> nchar conversion functions ************/
2126
2127    /* Create overloads for all standard functions that work with <ADT_1> for
2128       <OPAQUE_1> */
2129    function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2130      pragma BUILTIN('=', 1, 1, 1);
2131      pragma FIPSFLAG('=', 1450);
2132    function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2133      pragma BUILTIN('!=', 1, 1, 1);
2134      pragma FIPSFLAG('!=', 1450);
2135    function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2136      pragma BUILTIN('<', 1, 1, 1);
2137      pragma FIPSFLAG('<', 1450);
2138    function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2139      pragma BUILTIN('<=', 1, 1, 1);
2140      pragma FIPSFLAG('<=', 1450);
2141    function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2142      pragma BUILTIN('>', 1, 1, 1);
2143      pragma FIPSFLAG('>', 1450);
2144    function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2145      pragma BUILTIN('>=', 1, 1, 1);
2146      pragma FIPSFLAG('>=', 1450);
2147
2148    function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2149    function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2150    function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2151    function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2152    function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2153    function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2154    function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2155    function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2156    function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2157    function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2158    function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2159    function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2160    function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2161    function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2162    function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2163    function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2164    function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2165    function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
2166
2167    -- Outer Join
2168    function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
2169      pragma FIPSFLAG('(+)', 1450);
2170
2171    --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
2172    --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
2173    --    pragma BUILTIN('GREATEST', 1, 1, 1);
2174
2175    --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
2176    --    pragma BUILTIN('LEAST', 1, 1, 1);
2177
2178    function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
2179      return "<OPAQUE_1>";
2180      pragma BUILTIN('DECODE', 1, 1, 1);
2181
2182    function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
2183      pragma BUILTIN('IS NULL', 0, 3, 0);
2184      pragma FIPSFLAG('IS NULL', 1450);
2185
2186    function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
2187      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
2188      pragma FIPSFLAG('IS NOT NULL', 1450);
2189
2190    function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
2191      pragma FIPSFLAG('NVL', 1450);
2192
2193    --  REFs to opaques are not supported yet.
2194    --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
2195    --    pragma BUILTIN('VALUE', 1, 1, 1);
2196    --    pragma FIPSFLAG('VALUE', 1450);
2197
2198    --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
2199    --    pragma BUILTIN('REF', 1, 1, 1);
2200    --    pragma FIPSFLAG('REF', 1450);
2201
2202    --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
2203    --    pragma BUILTIN('DEREF', 1, 1, 1);
2204    --    pragma FIPSFLAG('DEREF', 1450);
2205
2206    -- overloadings for REF OPAQUE
2207
2208    --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
2209    --    pragma BUILTIN('IS NULL', 0, 3, 0);
2210    --    pragma FIPSFLAG('IS NULL', 1450);
2211
2212    --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
2213    --    pragma FIPSFLAG('IS NOT NULL', 1450);
2214
2215    --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
2216    --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
2217    --    pragma FIPSFLAG('IS DANGLING', 1450);
2218
2219    --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
2220    --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
2221    --    pragma FIPSFLAG('IS NOT DANGLING', 1450);
2222
2223    --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
2224    --    return REF "<OPAQUE_1>";
2225    --    pragma FIPSFLAG('NVL', 1450);
2226
2227    --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
2228    --    return BOOLEAN;
2229    --    pragma BUILTIN('=', 0, 3, 1);
2230    --    pragma FIPSFLAG('=', 1450);
2231
2232    --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
2233    --    return BOOLEAN;
2234    --    pragma BUILTIN('!=', 0, 3, 2);
2235    --    pragma FIPSFLAG('!=', 1450);
2236
2237    function GROUPING(a "<OPAQUE_1>") return NUMBER;
2238    function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") RETURN "<OPAQUE_1>";
2239
2240    function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
2241      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
2242    function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
2243      return TIME_TZ_UNCONSTRAINED;
2244      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
2245    function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
2246      return TIMESTAMP_UNCONSTRAINED;
2247      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
2248    function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
2249      return TIMESTAMP_TZ_UNCONSTRAINED;
2250      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
2251    function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
2252      return TIMESTAMP_LTZ_UNCONSTRAINED;
2253      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
2254    function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
2255      return YMINTERVAL_UNCONSTRAINED;
2256      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
2257    function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
2258      return DSINTERVAL_UNCONSTRAINED;
2259      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
2260
2261    function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
2262      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
2263    function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
2264      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
2265    function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
2266      return TIMESTAMP_UNCONSTRAINED;
2267      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
2268    function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
2269      return TIMESTAMP_TZ_UNCONSTRAINED;
2270      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
2271    function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
2272      return TIMESTAMP_LTZ_UNCONSTRAINED;
2273      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
2274    function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
2275      return YMINTERVAL_UNCONSTRAINED;
2276      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
2277    function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
2278      return DSINTERVAL_UNCONSTRAINED;
2279      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
2280
2281    function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
2282                     parms VARCHAR2) return VARCHAR2;
2283    function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
2284    function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
2285                     parms VARCHAR2) return VARCHAR2;
2286    function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
2287      return VARCHAR2;
2288    function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
2289                     parms VARCHAR2) return VARCHAR2;
2290    function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
2291      return VARCHAR2;
2292    function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
2293                     parms VARCHAR2) return VARCHAR2;
2294    function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
2295      return VARCHAR2;
2296    function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
2297                     parms VARCHAR2) return VARCHAR2;
2298    function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
2299      return VARCHAR2;
2300    function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
2301                     parms VARCHAR2) return VARCHAR2;
2302    function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
2303      return VARCHAR2;
2304    function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
2305                     parms VARCHAR2) return VARCHAR2;
2306    function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
2307      return VARCHAR2;
2308
2309    -- CONVERT FOR LOB --
2310    function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
2311                     DSTCSN VARCHAR2)
2312      return CLOB CHARACTER SET SRCSTR%CHARSET;
2313    function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
2314                     DSTCSN VARCHAR2,
2315                     SRCCSN VARCHAR2)
2316      return CLOB CHARACTER SET SRCSTR%CHARSET;
2317
2318    -- NLS_UPPER/NLS_LOWER FOR LOB --
2319    function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
2320                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
2321      return CLOB CHARACTER SET ch%CHARSET;
2322      pragma FIPSFLAG('NLS_UPPER', 1452);
2323    function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
2324      return CLOB CHARACTER SET ch%CHARSET;
2325      pragma FIPSFLAG('NLS_UPPER', 1452);
2326    function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
2327                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
2328      return CLOB CHARACTER SET ch%CHARSET;
2329      pragma FIPSFLAG('NLS_LOWER', 1452);
2330    function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
2331      return CLOB CHARACTER SET ch%CHARSET;
2332      pragma FIPSFLAG('NLS_LOWER', 1452);
2333
2334    function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
2335      return varchar2 character set ch%charset;
2336      pragma FIPSFLAG('COMPOSE', 1452);
2337    function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
2338                       canmode in VARCHAR2 DEFAULT 'CANONICAL')
2339      return varchar2 character set ch%charset;
2340      pragma FIPSFLAG('DECOMPOSE', 1452);
2341    FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
2342      return TIMESTAMP_UNCONSTRAINED;
2343
2344    -- Begin REGEXP Support (10iR1) --
2345
2346    -- REGEXP_LIKE --
2347    function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
2348                          pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
2349                          modifier VARCHAR2 DEFAULT NULL)
2350      return BOOLEAN;
2351      pragma FIPSFLAG('REGEXP_LIKE', 1452);
2352
2353    function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
2354                          pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
2355                          modifier VARCHAR2 DEFAULT NULL)
2356      return BOOLEAN;
2357      pragma FIPSFLAG('REGEXP_LIKE', 1452);
2358
2359    -- REGEXP_INSTR --
2360    function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
2361                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2362                          position    PLS_INTEGER := 1,
2363                          occurrence  PLS_INTEGER := 1,
2364                          returnparam PLS_INTEGER := 0,
2365                          modifier    VARCHAR2 DEFAULT NULL,
2366                          subexpression PLS_INTEGER := 0)
2367      return PLS_INTEGER;
2368      pragma FIPSFLAG('REGEXP_INSTR', 1452);
2369
2370    function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
2371                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2372                          position    INTEGER := 1,
2373                          occurrence  INTEGER := 1,
2374                          returnparam PLS_INTEGER := 0,
2375                          modifier    VARCHAR2 DEFAULT NULL,
2376                          subexpression PLS_INTEGER := 0)
2377      return INTEGER;
2378      pragma FIPSFLAG('REGEXP_INSTR', 1452);
2379
2380
2381    -- REGEXP_SUBSTR --
2382    function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
2383                           pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2384                           position    PLS_INTEGER := 1,
2385                           occurrence  PLS_INTEGER := 1,
2386                           modifier    VARCHAR2 DEFAULT NULL,
2387                           subexpression PLS_INTEGER := 0)
2388      return VARCHAR2 CHARACTER SET srcstr%CHARSET;
2389      pragma FIPSFLAG('REGEXP_SUBSTR', 1452);
2390
2391    function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
2392                           pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2393                           position    INTEGER := 1,
2394                           occurrence  INTEGER := 1,
2395                           modifier    VARCHAR2 DEFAULT NULL,
2396                           subexpression PLS_INTEGER := 0)
2397      return CLOB CHARACTER SET srcstr%CHARSET;
2398      pragma FIPSFLAG('REGEXP_SUBSTR', 1452);
2399
2400    -- REGEXP_REPLACE --
2401    function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
2402                            pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2403                            replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
2404                                          DEFAULT NULL,
2405                            position    PLS_INTEGER := 1,
2406                            occurrence  PLS_INTEGER := 0,
2407                            modifier    VARCHAR2 DEFAULT NULL)
2408      return VARCHAR2 CHARACTER SET srcstr%CHARSET;
2409      pragma FIPSFLAG('REGEXP_REPLACE', 1452);
2410
2411    function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
2412                            pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2413                            replacestr  CLOB CHARACTER SET srcstr%CHARSET
2414                                          DEFAULT NULL,
2415                            position    INTEGER := 1,
2416                            occurrence  INTEGER := 0,
2417                            modifier    VARCHAR2 DEFAULT NULL)
2418      return CLOB CHARACTER SET srcstr%CHARSET;
2419      pragma FIPSFLAG('REGEXP_REPLACE', 1452);
2420
2421    function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
2422                            pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2423                            replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
2424                                          DEFAULT NULL,
2425                            position    INTEGER := 1,
2426                            occurrence  INTEGER := 0,
2427                            modifier    VARCHAR2 DEFAULT NULL)
2428      return CLOB CHARACTER SET srcstr%CHARSET;
2429      pragma FIPSFLAG('REGEXP_REPLACE', 1452);
2430
2431    -- End REGEXP Support --
2432
2433    -- binary_float and binary_double functions and operators.
2434    function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
2435      pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
2436    function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
2437                       FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
2438      RETURN BINARY_FLOAT;
2439    function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
2440                       FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
2441                       PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
2442      RETURN BINARY_FLOAT;
2443
2444    function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
2445      pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
2446    function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
2447                       FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
2448      RETURN BINARY_DOUBLE;
2449    function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
2450                       FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
2451                       PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
2452      RETURN BINARY_DOUBLE;
2453
2454    function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
2455    function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
2456    function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
2457    function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
2458    function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
2459    function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
2460    function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
2461    function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
2462    function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
2463    function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
2464    function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
2465    function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
2466
2467    function TO_CHAR (left binary_float, format varchar2)
2468      return VARCHAR2;
2469    function TO_CHAR (left binary_double, format varchar2)
2470      return VARCHAR2;
2471
2472    function TO_CHAR(left binary_float, format varchar2, parms varchar2)
2473      return varchar2;
2474    function TO_CHAR(left binary_double, format varchar2, parms varchar2)
2475      return varchar2;
2476
2477    function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
2478    function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;
2479
2480    function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
2481      return nvarchar2;
2482    function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
2483      return nvarchar2;
2484
2485    function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
2486      pragma FIPSFLAG('REMAINDER', 1452);
2487    function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
2488      pragma FIPSFLAG(REMAINDER, 1452);
2489    function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
2490      pragma FIPSFLAG('REMAINDER', 1452);
2491    function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
2492      pragma FIPSFLAG(REMAINDER, 1452);
2493    function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
2494      pragma FIPSFLAG('REMAINDER', 1452);
2495    function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
2496      pragma FIPSFLAG(REMAINDER, 1452);
2497
2498    function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
2499      pragma BUILTIN('=',2, 2, 15);
2500    function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
2501      pragma BUILTIN('!=',5, 2, 16);
2502      pragma FIPSFLAG('!=', 1452);
2503    function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
2504      pragma BUILTIN('<',4, 2, 17);
2505    function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
2506      pragma BUILTIN('<=',6, 2, 18);
2507    function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
2508      pragma BUILTIN('>',1, 2, 19);
2509    function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
2510      pragma BUILTIN('>=',3, 2, 20);
2511
2512    function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
2513      pragma BUILTIN('IS NULL', 0, 2, 0);
2514    function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
2515      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
2516
2517    function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
2518      pragma FIPSFLAG('NVL', 1452);
2519
2520    function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
2521      pragma BUILTIN('+',14, 0, 1);
2522    function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
2523      pragma BUILTIN('-',15, 2, 23);
2524    function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
2525      pragma FIPSFLAG('ABS', 1452);
2526
2527    function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
2528      pragma BUILTIN('+',14, 2, 24);
2529    function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
2530      pragma BUILTIN('-',15, 2, 25);
2531    function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
2532      pragma BUILTIN('*',17, 2, 26);
2533    function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
2534      pragma BUILTIN('/',18, 2, 27);
2535
2536    function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
2537      pragma FIPSFLAG('REM', 1452);
2538    function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
2539      pragma FIPSFLAG('MOD', 1452);
2540
2541    function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
2542      pragma FIPSFLAG('FLOOR', 1452);
2543    function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
2544      pragma FIPSFLAG('CEIL', 1452);
2545    function SIGN(f BINARY_FLOAT) return SIGNTYPE;
2546      pragma FIPSFLAG('SIGN', 1452);
2547    function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
2548      pragma FIPSFLAG('SQRT', 1452);
2549
2550    function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
2551      pragma FIPSFLAG('TRUNC', 1452);
2552
2553    function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
2554      pragma FIPSFLAG('ROUND', 1452);
2555
2556    function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
2557      pragma BUILTIN('=',2, 2, 28);
2558    function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
2559      -- also <> and ~=
2560      pragma BUILTIN('!=',5, 2, 29);
2561      pragma FIPSFLAG('!=', 1452);
2562    function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
2563      pragma BUILTIN('<',4, 2, 30);
2564    function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
2565      pragma BUILTIN('<=',6, 2, 31);
2566    function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
2567      pragma BUILTIN('>',1, 2, 32);
2568    function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
2569      pragma BUILTIN('>=',3, 2, 33);
2570
2571    function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
2572      pragma BUILTIN('IS NULL', 0, 2, 0);
2573    function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
2574      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
2575
2576    function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
2577      pragma FIPSFLAG('NVL', 1452);
2578
2579    function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
2580      pragma BUILTIN('+',14, 0, 1);
2581    function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
2582      pragma BUILTIN('-',15, 2, 36);
2583    function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
2584      pragma FIPSFLAG('ABS', 1452);
2585
2586    function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
2587      pragma FIPSFLAG('ACOS', 1452);
2588
2589    function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
2590      pragma FIPSFLAG('ASIN', 1452);
2591
2592    function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
2593      pragma FIPSFLAG('ATAN', 1452);
2594
2595    function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
2596      pragma FIPSFLAG('ATAN2', 1452);
2597
2598    function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
2599      pragma BUILTIN('+',14, 2, 37);
2600    function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
2601      pragma BUILTIN('-',15, 2, 38);
2602    function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
2603      pragma BUILTIN('*',17, 2, 39);
2604    function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
2605      pragma BUILTIN('/',18, 2, 40);
2606
2607    function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
2608      return BINARY_DOUBLE;
2609      pragma FIPSFLAG('REM', 1452);
2610    function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
2611      pragma FIPSFLAG('MOD', 1452);
2612
2613    function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
2614      return BINARY_DOUBLE;
2615      pragma FIPSFLAG('**', 1452);
2616
2617    function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
2618      pragma FIPSFLAG('FLOOR', 1452);
2619    function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
2620      pragma FIPSFLAG('CEIL', 1452);
2621    function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
2622      pragma FIPSFLAG('SQRT', 1452);
2623    function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
2624    pragma FIPSFLAG('SIGN', 1452);
2625
2626    function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
2627    function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
2628    function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
2629    function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
2630    function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
2631    function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
2632    function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
2633    function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;
2634
2635    function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
2636
2637    function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
2638      pragma FIPSFLAG('TRUNC', 1452);
2639
2640    function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
2641      pragma FIPSFLAG('ROUND', 1452);
2642
2643    function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
2644      pragma FIPSFLAG('POWER', 1452);
2645
2646    function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
2647    function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
2648    function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
2649
2650    function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
2651      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
2652    function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
2653      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
2654    function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
2655      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
2656    function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
2657      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
2658
2659
2660    function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
2661      pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
2662    function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
2663      pragma BUILTIN('-',15, 2, 41);
2664    function ABS(I PLS_INTEGER) return PLS_INTEGER;
2665      pragma FIPSFLAG('ABS', 1452);
2666
2667    function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
2668      pragma BUILTIN('+',14, 2, 42);
2669    function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
2670      pragma BUILTIN('-',14, 2, 43);
2671    function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
2672      pragma BUILTIN('*',14, 2, 44);
2673
2674    function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
2675      pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
2676    function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
2677      -- also <> and ~=
2678      pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
2679      pragma FIPSFLAG('!=', 1452);
2680    function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
2681      pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
2682    function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
2683      pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
2684    function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
2685      pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
2686    function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
2687      pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE
2688
2689    function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
2690      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
2691    function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
2692      pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL
2693
2694    function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
2695      pragma FIPSFLAG('NVL', 1452);
2696
2697    function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
2698      pragma FIPSFLAG('TRUNC', 1452);
2699
2700    function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
2701      pragma FIPSFLAG('ROUND', 1452);
2702
2703    function SIGN(i PLS_INTEGER) return SIGNTYPE;
2704      pragma FIPSFLAG('SIGN', 1452);
2705
2706    function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
2707      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
2708    function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
2709      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
2710
2711    -- MultiSet Functions and Operators.
2712
2713    -- Equality
2714    function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
2715      return BOOLEAN;
2716        pragma BUILTIN('=',2, 16, 1);
2717
2718    function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
2719      return BOOLEAN;
2720        pragma BUILTIN('!=',2, 16, 2);
2721
2722    function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;
2723
2724    function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
2725      pragma BUILTIN('SET',18, 5, 40);-- Dummy
2726
2727    function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
2728      pragma BUILTIN('IS A SET',18, 5, 41);-- Dummy
2729    function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
2730      pragma BUILTIN('IS NOT A SET',18, 5, 42);-- Dummy
2731
2732    function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
2733    function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;
2734
2735    -- IS A SUBMULTISET OF
2736    function 'SUBMULTISET' (collection IN  "<TABLE_1>",
2737                            collection2 IN "<TABLE_1>")
2738      return BOOLEAN;
2739        pragma BUILTIN('SUBMULTISET',18, 5, 43);
2740
2741    function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
2742                                   collection2 IN "<TABLE_1>")
2743      return "<TABLE_1>";
2744        pragma BUILTIN('MULTISET_UNION_ALL',18, 5, 44);
2745
2746    function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
2747                                        collection2 IN "<TABLE_1>")
2748      return "<TABLE_1>";
2749      pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 5, 45);-- Dummy
2750
2751    function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
2752                                   collection2 IN "<TABLE_1>")
2753      return "<TABLE_1>";
2754      pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 5, 46);-- Dummy
2755
2756    function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
2757                                        collection2 IN "<TABLE_1>")
2758      return "<TABLE_1>";
2759      pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 5, 47);-- Dummy
2760
2761    function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
2762                                   collection2 IN "<TABLE_1>")
2763      return "<TABLE_1>";
2764      pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 5, 48);-- Dummy
2765
2766    function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
2767                                        collection2 IN "<TABLE_1>")
2768      return "<TABLE_1>";
2769      pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 5, 49);-- Dummy
2770
2771    -- These are dummy procedures for correct management of new control
2772    -- statements added to PL/SQL. They ensure local procedures which have the
2773    -- same names as newly introduced keywords are not masked by those keywords.
2774
2775    procedure continue;
2776
2777    -- REGEXP_COUNT --
2778    function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
2779                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2780                          position    PLS_INTEGER := 1,
2781                          modifier    VARCHAR2 DEFAULT NULL)
2782      return PLS_INTEGER;
2783      pragma FIPSFLAG('REGEXP_COUNT', 1452);
2784
2785    function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
2786                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
2787                          position    INTEGER := 1,
2788                          modifier    VARCHAR2 DEFAULT NULL)
2789      return INTEGER;
2790      pragma FIPSFLAG('REGEXP_COUNT', 1452);
2791
2792    -- 47322: JSON
2793    -- Support for SYS$STANDARD_JSON is still needed for old databases
2794    function " SYS$STANDARD_JSON" return VARCHAR2;
2795
2796    /* Bug 22106671: LOB Extensions Project.
2797     * PL/SQL standard will support the following LOB conversions on
2798     * version 19.1. The default character set in TO_CLOB/TO_CHAR operations
2799     * is set to UTF-8 during runtime if necessary.
2800     */
2801    FUNCTION TO_CLOB(LEFT BLOB, CSID NUMBER DEFAULT NULL) RETURN CLOB;
2802    FUNCTION TO_CLOB(LEFT BFILE, CSID NUMBER DEFAULT NULL) RETURN CLOB;
2803    FUNCTION TO_BLOB(LEFT BFILE) RETURN BLOB;
2804    FUNCTION TO_CHAR(LEFT BLOB, CSID NUMBER DEFAULT NULL) RETURN VARCHAR2;
2805    FUNCTION TO_CHAR(LEFT BFILE, CSID NUMBER DEFAULT NULL) RETURN VARCHAR2;
2806
2807    /* End of 19.1 LOB Builtin Functions. */
2808
2809    function "JSON_ARRAY" return VARCHAR2;
2810      PRAGMA BUILTIN('JSON_ARRAY', 0, 6, 1);
2811    function "JSON_OBJECT" return VARCHAR2;
2812      PRAGMA BUILTIN('JSON_OBJECT', 0, 6, 2);
2813    function "JSON_VALUE" return VARCHAR2;
2814      PRAGMA BUILTIN('JSON_VALUE', 0, 6, 3);
2815    function "IS_JSON" return VARCHAR2;
2816      PRAGMA BUILTIN('IS_JSON', 0, 6, 4);
2817    function "IS_NOT_JSON" return VARCHAR2;
2818      PRAGMA BUILTIN('IS_NOT_JSON', 0, 6, 5);
2819    function "JSON_EXISTS" return VARCHAR2;
2820      PRAGMA BUILTIN('JSON_EXISTS', 0, 6, 6);
2821    function "JSON_QUERY" return VARCHAR2;
2822      PRAGMA BUILTIN('JSON_QUERY', 0, 6, 7);
2823
2824    --#### All user-visible declarations should precede this point.  The
2825    --#### following are implementation-oriented pragmas that may need
2826    --#### editing in the future; we would prefer to be able to edit them
2827    --#### without affecting the rft numbering of user-visible items.
2828
2829    --#### interface pragmas
2830
2831    --#### Note that for any ICD which maps directly to a PVM
2832    --#### Opcode MUST be mapped to pes_dummy.
2833    --#### An ICD which invokes another ICD by flipping operands is
2834    --#### mapped to pes_flip, and an ICD whose result is the inverse of
2835    --#### another ICD is mapped to pes_invert
2836    --#### New ICDs should be placed at the end of this list, and a
2837    --#### corresponding entry must be made in the ICD table in pdz7
2838
2839    PRAGMA interface(c,length,"pes_dummy",1);
2840    PRAGMA interface(c,substr,"pes_dummy",1);
2841    PRAGMA interface(c,instr,"pesist",1);
2842    PRAGMA interface(c,UPPER,"pesupp",1);
2843    PRAGMA interface(c,LOWER,"peslow",1);
2844    PRAGMA interface(c,ASCII,"pesasc");
2845    PRAGMA interface(c,ASCIISTR,"pesastr");
2846    PRAGMA interface(c,UNISTR,"pesustr");
2847    PRAGMA interface(c,CHR,"peschr");
2848    PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
2849    PRAGMA interface(c,INITCAP,"pesicp");
2850    PRAGMA interface(c,LPAD,"peslpd",1);
2851    PRAGMA interface(c,LPAD,"peslpd",2);
2852    PRAGMA interface(c,RPAD,"pesrpd",1);
2853    PRAGMA interface(c,RPAD,"pesrpd",2);
2854    PRAGMA interface(c,REPLACE,"pesrep",1);
2855    PRAGMA interface(c,LTRIM,"pesltr",1);
2856    PRAGMA interface(c,LTRIM,"pesltr",2);
2857    PRAGMA interface(c,RTRIM,"pesrtr",1);
2858    PRAGMA interface(c,RTRIM,"pesrtr",2);
2859    PRAGMA interface(c,'LIKE',"peslik",1);
2860    PRAGMA interface(c,'LIKE',"pesli2",2);
2861    PRAGMA interface(c,ABS,"pes_dummy",1);
2862    PRAGMA interface(c,'REM',"pesmod", 1);
2863    PRAGMA interface(c,'MOD',"pesmod", 1);
2864    PRAGMA interface(c,floor,"pesflo", 1);
2865    PRAGMA interface(c,CEIL,"pescei", 1);
2866    PRAGMA interface (c, SQRT, "pessqt", 1);
2867    PRAGMA interface(c,SIGN,"pessgn", 1);
2868    PRAGMA interface(c,cos,"pescos", 1);
2869    PRAGMA interface(c,sin,"pessin",1);
2870    PRAGMA interface(c,TAN,"pestan",1);
2871    PRAGMA interface(c,COSH,"pescsh",1);
2872    PRAGMA interface(c,SINH,"pessnh",1);
2873    PRAGMA interface(c,TANH,"pestnh",1);
2874    PRAGMA interface(c,EXP,"pesexp",1);
2875    PRAGMA interface(c,LN,"pesln",1);
2876    PRAGMA interface(c,BITAND,"pesbtd",1);
2877    PRAGMA interface(c,BITAND,"pesbtdn",2);
2878    PRAGMA interface(c,LOG,"peslog",1);
2879    PRAGMA interface(c,TRUNC,"pestru",1);
2880    PRAGMA interface(c,ROUND,"pesrnd",1);
2881    PRAGMA interface(c,POWER,"pespow",1);
2882    PRAGMA interface(c,NEW_TIME,"pesnwt");
2883    PRAGMA interface(c,TO_DATE,"pesc2d",4);
2884    PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
2885    PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
2886    PRAGMA interface(c,'>=',"pes_flip",5);
2887    PRAGMA interface(c,'>',"pes_flip",5);
2888    PRAGMA interface(c,'<=',"peszle",5);
2889    PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
2890    PRAGMA interface(c,'=',"peszeq",5);
2891    PRAGMA interface(c,'!=',"pes_invert",5);
2892    PRAGMA interface(c,nlssort,"pesxco",2);
2893    PRAGMA interface(c,NLS_UPPER,"pesxup",1);
2894    PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
2895    PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
2896    PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
2897    PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
2898    PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
2899    PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
2900    PRAGMA interface(c,lengthb,"pes_dummy",1);
2901    PRAGMA interface(c,substrb,"pes_dummy",1);
2902    PRAGMA interface(c,instrb,"pesxis",1);
2903    PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
2904    PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
2905    PRAGMA interface(c,TO_CHAR,"pesd2c",5);
2906    PRAGMA interface(c,TO_CHAR,"pesn2c",6);
2907    PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
2908    PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
2909    PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
2910    PRAGMA interface(c,ATAN,"pesatan",1);
2911    PRAGMA interface(c,EMPTY_CLOB,"peslcem");
2912    PRAGMA interface(c,EMPTY_BLOB,"peslbem");
2913    PRAGMA interface(c,BFILENAME,"pesfnm");
2914    PRAGMA interface(c,TO_TIME,"pes3tm",2);
2915    PRAGMA interface(c,TO_TIME,"pes3tm",3);
2916    PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
2917    PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
2918    PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
2919    PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
2920    PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
2921    PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
2922    PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
2923    PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
2924    PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
2925    PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
2926    PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
2927    PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
2928    PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
2929    PRAGMA interface(c,TRIM,"pestrim",1);
2930    -- Datetime addition
2931    PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
2932    PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
2933    PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
2934    PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
2935    PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
2936    PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
2937    PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
2938    PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
2939    PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
2940    PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
2941    PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
2942    PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
2943    PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
2944    PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
2945    PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
2946    PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
2947    PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
2948    PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
2949    PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
2950    PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
2951    PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
2952    PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
2953    -- Datetime subtraction
2954    PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
2955    PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
2956    PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
2957    PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
2958    PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
2959    PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
2960    PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
2961    PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
2962    PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
2963    PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
2964    PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
2965    PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
2966    PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
2967    PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
2968    PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
2969    PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
2970    PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
2971    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
2972    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
2973    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
2974    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
2975    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
2976    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
2977    PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
2978    PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
2979    PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
2980    PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
2981    -- Datetime multiplication
2982    PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
2983    PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
2984    PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
2985    PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
2986    -- Datetime division
2987    PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
2988    PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
2989    -- TIME
2990    PRAGMA interface(c,'=',"pes_dummy",9);
2991    PRAGMA interface(c,'!=',"pes_invert",9);
2992    PRAGMA interface(c,'>',"pes_flip",8);
2993    PRAGMA interface(c,'<',"pes_dummy",8);
2994    PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
2995    PRAGMA interface(c,'<=',"pes_dummy",8);
2996    -- TIME WITH TIME ZONE
2997    PRAGMA interface(c,'=',"pes_dummy",10);
2998    PRAGMA interface(c,'!=',"pes_invert",10);
2999    PRAGMA interface(c,'>',"pes_flip",9);
3000    PRAGMA interface(c,'<',"pes_dummy",9);
3001    PRAGMA interface(c,'>=',"pes_flip",9);
3002    PRAGMA interface(c,'<=',"pes_dummy",9);
3003    -- TIMESTAMP
3004    PRAGMA interface(c,'=',"pes_dummy",11);
3005    PRAGMA interface(c,'!=',"pes_invert",11);
3006    PRAGMA interface(c,'>',"pes_flip",10);
3007    PRAGMA interface(c,'<',"pes_dummy",10);
3008    PRAGMA interface(c,'>=',"pes_flip",10);
3009    PRAGMA interface(c,'<=',"pes_dummy",10);
3010    -- INTERVAL YEAR TO MONTH
3011    PRAGMA interface(c,'=',"pes_dummy",12);
3012    PRAGMA interface(c,'!=',"pes_invert",12);
3013    PRAGMA interface(c,'>',"pes_flip",11);
3014    PRAGMA interface(c,'<',"pes_dummy",11);
3015    PRAGMA interface(c,'>=',"pes_flip",11);
3016    PRAGMA interface(c,'<=',"pes_dummy",11);
3017    -- INTERVAL DAY TO SECOND
3018    PRAGMA interface(c,'=',"pes_dummy",13);
3019    PRAGMA interface(c,'!=',"pes_invert",13);
3020    PRAGMA interface(c,'>',"pes_flip",12);
3021    PRAGMA interface(c,'<',"pes_dummy",12);
3022    PRAGMA interface(c,'>=',"pes_flip",12);
3023    PRAGMA interface(c,'<=',"pes_dummy",12);
3024    -- TIMESTAMP_TZ_UNCONSTRAINED
3025    PRAGMA interface(c,'=',"pes_dummy",14);
3026    PRAGMA interface(c,'!=',"pes_invert",14);
3027    PRAGMA interface(c,'>',"pes_flip",13);
3028    PRAGMA interface(c,'<',"pes_dummy",13);
3029    PRAGMA interface(c,'>=',"pes_flip",13);
3030    PRAGMA interface(c,'<=',"pes_dummy",13);
3031    -- TIMESTAMP WITH LOCAL TIME ZONE
3032    PRAGMA interface(c,'=',"pes_dummy",15);
3033    PRAGMA interface(c,'!=',"pes_invert",15);
3034    PRAGMA interface(c,'>',"pes_flip",14);
3035    PRAGMA interface(c,'<',"pes_dummy",14);
3036    PRAGMA interface(c,'>=',"pes_flip",14);
3037    PRAGMA interface(c,'<=',"pes_dummy",14);
3038    -- Other datetime functions
3039    PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
3040    PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
3041    PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
3042    --  Internal calls to evaluate datetime/interval literals without NLS parms.
3043    PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
3044    PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
3045    PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
3046    PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
3047    PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
3048    PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
3049    PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
3050    -- extract(field from expr)
3051    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
3052    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
3053    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
3054    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
3055    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
3056    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
3057    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
3058    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
3059    -- datetime is null
3060    PRAGMA interface(c,'IS NULL',"pes_dummy",15); -- time
3061    PRAGMA interface(c,'IS NULL',"pes_dummy",16); -- time wtz
3062    PRAGMA interface(c,'IS NULL',"pes_dummy",17); -- timestamp
3063    PRAGMA interface(c,'IS NULL',"pes_dummy",18); -- timestamp wtz
3064    PRAGMA interface(c,'IS NULL',"pes_dummy",19); -- timestamp lwtz
3065    PRAGMA interface(c,'IS NULL',"pes_dummy",20); -- interval ym
3066    PRAGMA interface(c,'IS NULL',"pes_dummy",21); -- interval ds
3067
3068    -- 8.2 LOB Built-in Functions
3069    PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
3070    PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
3071    PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
3072    PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
3073    PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
3074    PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
3075    PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
3076    PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
3077    PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
3078    PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
3079    PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
3080    PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
3081    PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
3082    PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
3083    PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
3084    PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
3085    PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
3086    PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
3087    PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
3088    PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
3089    PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
3090    PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
3091    PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
3092    PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
3093    PRAGMA interface(c,nvl,"peslcnl",18);       -- LOB NVL
3094    PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE
3095
3096       -- LOB Relational Operators
3097       -- LHS: CLOB,    RHS:CLOB
3098    PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
3099    PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
3100    PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
3101    PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
3102    PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
3103    PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
3104       -- LHS: CLOB,     RHS:VARCHAR2
3105    PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
3106    PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
3107    PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
3108    PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
3109    PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
3110    PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
3111       -- LHS: VARCHAR2, RHS:CLOB
3112    PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
3113    PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
3114    PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
3115    PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
3116    PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
3117    PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='
3118
3119    PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
3120    PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
3121    -- End of 8.2 LOB Built-in Functions
3122
3123
3124    PRAGMA interface(c,tz_offset,"pestzo",1);
3125    PRAGMA interface(c,from_tz,"pesftz",1);
3126
3127    PRAGMA interface(c,ISNCHAR,"pesinc", 1);
3128
3129    PRAGMA interface(c,CONVERT,"pescnv", 1);
3130    PRAGMA interface(c,CONVERT,"pescnv", 2);
3131    PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
3132    PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT
3133
3134    PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
3135    PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
3136    PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);
3137
3138    PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
3139    PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
3140    PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
3141    PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
3142    PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
3143    PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
3144    PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
3145    PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
3146    PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
3147    PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
3148    PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
3149    PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
3150    PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
3151    PRAGMA interface(c,TO_CHAR,"pesitv2c",20);
3152
3153    --#### new_names pragmas
3154
3155    -- This is an internal pragma that restricts the use
3156    -- of particular new entries in package standard.
3157    -- It is only valid in package standard.
3158    -- Note that left out of the 8.1.5 set are non datetime
3159    -- entries urowid, "UROWID ", self_is_null and trim.
3160
3161    pragma new_names('8.1.5',
3162                     time,"TIME WITH TIME ZONE",
3163                     timestamp,"TIMESTAMP WITH TIME ZONE",
3164                     "INTERVAL DAY TO SECOND",
3165                     "INTERVAL YEAR TO MONTH",
3166                     to_time, to_timestamp,
3167                     to_time_tz, to_timestamp_tz,
3168                     " SYS$DSINTERVALSUBTRACT",
3169                     " SYS$YMINTERVALSUBTRACT",
3170                     to_yminterval,to_dsinterval,
3171                     NUMTOYMINTERVAL, NUMTODSINTERVAL,
3172                     current_date,
3173                     current_time,current_timestamp);
3174
3175    pragma new_names('8.1.6',
3176                     dbtimezone, sessiontimezone, localtimestamp,
3177                     localtime,
3178                     cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");
3179
3180    -- Should there be a 8.2 new names pragma ?
3181
3182    -- 8.2 UCS2/UCS4/Complete Built-in Functions
3183
3184    PRAGMA interface(c,INSTR2,"pesist2",1);
3185    PRAGMA interface(c,INSTR4,"pesist4",1);
3186    PRAGMA interface(c,INSTRC,"pesistc",1);
3187
3188    PRAGMA interface(c,LENGTH2,"peslen2",1);
3189    PRAGMA interface(c,LENGTH4,"peslen4",1);
3190    PRAGMA interface(c,LENGTHC,"peslenc",1);
3191
3192    PRAGMA interface(c,LIKE2,"peslik2",1);
3193    PRAGMA interface(c,LIKE2,"pesli22",2);
3194    PRAGMA interface(c,LIKE4,"peslik4",1);
3195    PRAGMA interface(c,LIKE4,"pesli42",2);
3196    PRAGMA interface(c,LIKEC,"peslikc",1);
3197    PRAGMA interface(c,LIKEC,"peslic2",2);
3198
3199    PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
3200    PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
3201    PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
3202    PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
3203    PRAGMA interface(c,COMPOSE,"pescomp");
3204    PRAGMA interface(c,DECOMPOSE,"pesdcmp");
3205
3206
3207
3208    -- End of 8.2 UCS2/UCS4/Complete Built-in Functions
3209
3210    -- Begin REGEXP support (10iR1) --
3211    PRAGMA interface(c,regexp_like,    "pes_dummy",1);
3212    PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
3213    PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
3214    PRAGMA interface(c,regexp_replace, "pes_dummy",1);
3215    PRAGMA interface(c,regexp_count,   "pes_dummy",1);
3216    PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
3217    PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
3218    PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
3219    PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
3220    PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
3221    PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE
3222
3223    -- End of REGEXP Built-in Functions --
3224
3225
3226    -- 10i Binary Floating-point Built-in Functions
3227
3228    PRAGMA interface(c,'IS NAN',"pesnanf",2);
3229    PRAGMA interface(c,'IS NAN',"pesnand",3);
3230    PRAGMA interface(c,'IS INFINITE',"pesinf",1);
3231    PRAGMA interface(c,'IS INFINITE',"pesinff",2);
3232    PRAGMA interface(c,'IS INFINITE',"pesinfd",3);
3233    PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
3234    PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
3235    PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
3236    PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
3237    PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
3238    PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
3239    PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
3240    PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
3241    PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
3242    PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
3243    PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
3244    PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
3245    PRAGMA interface(c,'REMAINDER',"pesrem", 1);
3246    PRAGMA interface(c,REMAINDER,"pesrem", 2);
3247    PRAGMA interface(c,'REMAINDER',"pesremf", 3);
3248    PRAGMA interface(c,REMAINDER,"pesremf", 4);
3249    PRAGMA interface(c,'REMAINDER',"pesremd", 5);
3250    PRAGMA interface(c,REMAINDER,"pesremd", 6);
3251    PRAGMA interface(c,ABS,"pes_dummy",2);
3252    PRAGMA interface(c,ABS,"pes_dummy",3);
3253    PRAGMA interface(c,ABS,"pes_dummy",4);
3254    PRAGMA interface(c,ATAN,"pesatand",2);
3255    PRAGMA interface(c,'REM',"pesmodf", 2);
3256    PRAGMA interface(c,'MOD',"pesmodf", 2);
3257    PRAGMA interface(c,'REM',"pesmodd", 3);
3258    PRAGMA interface(c,'MOD',"pesmodd", 3);
3259    PRAGMA interface(c,floor,"pesflof", 2);
3260    PRAGMA interface(c,floor,"pesflod", 3);
3261    PRAGMA interface(c,CEIL,"pesceif", 2);
3262    PRAGMA interface(c,CEIL,"pesceid", 3);
3263    PRAGMA interface (c, SQRT, "pessqtf", 2);
3264    PRAGMA interface (c, SQRT, "pessqtd", 3);
3265    PRAGMA interface(c,SIGN,"pessgnf", 2);
3266    PRAGMA interface(c,SIGN,"pessgnd", 3);
3267    PRAGMA interface(c,SIGN,"pessgni", 4);
3268    PRAGMA interface(c,cos,"pescosd", 2);
3269    PRAGMA interface(c,sin,"pessind",2);
3270    PRAGMA interface(c,TAN,"pestand",2);
3271    PRAGMA interface(c,COSH,"pescshd",2);
3272    PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
3273    PRAGMA interface(c,TANH,"pestnhd",2);
3274    PRAGMA interface(c,EXP,"pesexpd",2);
3275    PRAGMA interface(c,LN,"peslnd",2);
3276    PRAGMA interface(c,LOG,"peslogd",2);
3277    PRAGMA interface(c,TRUNC,"pestruf",4);
3278    PRAGMA interface(c,TRUNC,"pestrud",5);
3279    PRAGMA interface(c,TRUNC,"pestrui",6);
3280    PRAGMA interface(c,ROUND,"pesrndf",4);
3281    PRAGMA interface(c,ROUND,"pesrndd",5);
3282    PRAGMA interface(c,ROUND,"pesrndi",6);
3283    PRAGMA interface(c,POWER,"pespowd",2);
3284
3285    -- End of 10i Binary Floating-point Built-in Functions
3286
3287    -- ICDs for MULTISET
3288
3289    PRAGMA interface(c,CARDINALITY,"pesmcnt");
3290    PRAGMA interface(c,'IS EMPTY',"pesmie");
3291    PRAGMA interface(c,'IS NOT EMPTY',"pes_invert",1);
3292    -- ICDs which used to be in the body of standard, but which new COG can
3293    -- handle directly
3294
3295    -- NOT (some ICD)
3296    PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
3297    PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
3298    PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
3299    PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
3300    PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
3301    PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
3302    PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
3303    PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
3304    PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
3305    PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
3306    PRAGMA interface(c,'IS NOT NAN',"pes_invert",2);
3307    PRAGMA interface(c,'IS NOT NAN',"pes_invert",3);
3308    PRAGMA interface(c,'IS NOT INFINITE',"pes_invert",1);
3309    PRAGMA interface(c,'IS NOT INFINITE',"pes_invert",2);
3310    PRAGMA interface(c,'IS NOT INFINITE',"pes_invert",3);
3311
3312    -- datetime is not null
3313    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",15); -- time
3314    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",16); -- time wtz
3315    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",17); -- timestamp
3316    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",18); -- timestamp wtz
3317    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",19); -- timestamp lwtz
3318    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",20); -- interval ym
3319    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",21); -- interval ds
3320
3321    -- Misc
3322    PRAGMA interface(c,'**',   "pespow",1);    -- number
3323    PRAGMA interface(c,'**',   "pespowd",2);   -- binary double
3324    PRAGMA interface(c,ACOS, "pesacosd",2);  -- binary double
3325    PRAGMA interface(c,ASIN, "pesasind",2);  -- binary double
3326    PRAGMA interface(c,ATAN2,"pesatn2d",2);  -- binary double
3327
3328    -- All the flavors of NVL
3329    PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
3330    PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
3331    PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
3332    PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
3333    PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
3334    PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
3335    PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
3336    PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection
3337
3338  --  Ref Cursor has problems. The MOVCR instruction needs more information than
3339  --  the other MOV* instructions, including the PVM register of the destination
3340  --  This cannot be easily supplied through the generic NVL instruction, so
3341  --  for now, this flavor will continue to have a real body
3342  --  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor
3343
3344    PRAGMA interface(c,nvl,"pes_dummy",10);       -- Assoc_array
3345    PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time
3346    PRAGMA interface(c,nvl,"pes_dummy",12);       -- Time-tz
3347    PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp
3348    PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-tz
3349    PRAGMA interface(c,nvl,"pes_dummy",15);       -- Timestamp-ltz
3350    PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalym
3351    PRAGMA interface(c,nvl,"pes_dummy",17);       -- Intervalds
3352  --  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Clob (Handled above, ICD)
3353    PRAGMA interface(c,nvl,"pes_dummy",19);       -- Opaque
3354    PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binaryfloat
3355    PRAGMA interface(c,nvl,"pes_dummy",21);       -- Binarydouble
3356    PRAGMA interface(c,nvl,"pes_dummy",22);       -- PLSInteger
3357
3358    -- 47322: JSON
3359    PRAGMA interface(c," SYS$STANDARD_JSON","pes_dummy",1);
3360
3361    -- Bug 26851555: round_ties_to_even
3362    PRAGMA interface(c,ROUND_TIES_TO_EVEN,"pesrndeven",1);
3363
3364    -- Bug 22106671: LOB Extensions
3365    PRAGMA interface(c,TO_CLOB,"peslblb2clb",3);  -- Blob To Clob
3366    PRAGMA interface(c,TO_CLOB,"peslbfi2clb",4);  -- BFile To Clob
3367    PRAGMA interface(c,TO_BLOB,"peslbfi2blb",2);  -- BFile To Blob
3368    PRAGMA interface(c,TO_CHAR,"peslblb2txt",25); -- Blob To Text
3369    PRAGMA interface(c,TO_CHAR,"peslbfi2txt",26); -- BFile To Text
3370
3371    /* End of 19.1 LOB Builtin Functions. */
3372
3373    -- The following pragma overrides any other setting of the timestamp,
3374    -- and is used so that we recognize the client-side and server-side instances
3375    -- of package STANDARD as being the same.  Package STANDARD is special in
3376    -- that it is really the root of the PL/SQL dependencies graph; as such it
3377    -- itself doesn't ever need recompiling due to changes to things below it.
3378    -- The pragma mechanism used here is currently ignored except for
3379    -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
3380    -- to your own code as it may in future interfere with the package
3381    -- consistency maintenance mechanisms and could have dire results.
3382
3383    --#### timestamp pragma (please keep this last)
3384    pragma TIMESTAMP('2018-07-16:00:00:00');
3385  end;
3386
3387  /

Package created.

Elapsed: 00:00:03.51
SQL> @?/rdbms/admin/sqlsessend.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/sqlsessend.sql /main/3 2018/07/25 13:50:02 surman Exp $
SQL> Rem
SQL> Rem sqlsessend.sql
SQL> Rem
SQL> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      sqlsessend.sql - SQL session end
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Any commands which should be run at the end of all oracle
SQL> Rem      supplied scripts.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      See sqlsessstart.sql for the corresponding start script.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessend.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessend.sql
SQL> Rem    SQL_PHASE: MISC
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    surman      03/08/13 - 16462837: Common start and end scripts
SQL> Rem    surman      03/08/13 - Created
SQL> Rem
SQL>
SQL> alter session set "_ORACLE_SCRIPT" = false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL>
SQL> @@stdbody.sql
SQL> @@?/rdbms/admin/sqlsessstart.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/sqlsessstart.sql /main/3 2018/07/25 13:50:02 surman Exp $
SQL> Rem
SQL> Rem sqlsessstart.sql
SQL> Rem
SQL> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      sqlsessstart.sql - SQL session start
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Any commands which should be run at the start of all oracle
SQL> Rem      supplied scripts.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      See sqlsessend.sql for the corresponding end script.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessstart.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessstart.sql
SQL> Rem    SQL_PHASE: MISC
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    surman      03/08/13 - 16462837: Common start and end scripts
SQL> Rem    surman      03/08/13 - Created
SQL> Rem
SQL>
SQL> alter session set "_ORACLE_SCRIPT" = true;

Session altered.

Elapsed: 00:00:00.00
SQL> create or replace
  2  package body STANDARD is         -- careful on this line; SED edit occurs!
  3
  4  subtype Cursor_Handle is binary_integer range 0..255;
  5
  6  INVALID_USERENV_PARAMETER exception;
  7  pragma EXCEPTION_INIT(INVALID_USERENV_PARAMETER, -2003);
  8
  9  -- This exception is used by several sped-up STANDARD functions' ICDs to
 10  -- indicate that the ICD is unable to compute the result, and that SQL should
 11  -- be used to do the computation.
 12  ICD_UNABLE_TO_COMPUTE exception;
 13  pragma EXCEPTION_INIT(ICD_UNABLE_TO_COMPUTE, -6594);
 14
 15  -- icds
 16
 17    function pesxlt(ch VARCHAR2 CHARACTER SET ANY_CS,
 18                    cpy VARCHAR2 CHARACTER SET ch%CHARSET,
 19                    frm VARCHAR2 CHARACTER SET ch%CHARSET,
 20                    too VARCHAR2 CHARACTER SET ch%CHARSET)
 21          return VARCHAR2 CHARACTER SET ch%CHARSET;
 22      pragma interface (c,pesxlt);
 23
 24  -- trig fns
 25    function pesxco(c VARCHAR2 CHARACTER SET ANY_CS, format VARCHAR2) return raw;
 26      pragma interface (c,pesxco);
 27
 28    function pesxup(ch VARCHAR2 CHARACTER SET ANY_CS, format VARCHAR2)
 29          return VARCHAR2 CHARACTER SET ch%CHARSET;
 30      pragma interface (c,pesxup);
 31
 32    function pesxlo(ch VARCHAR2 CHARACTER SET ANY_CS, format VARCHAR2)
 33          return VARCHAR2 CHARACTER SET ch%CHARSET;
 34      pragma interface (c,pesxlo);
 35
 36    function pesxcp(ch VARCHAR2 CHARACTER SET ANY_CS, format VARCHAR2)
 37          return VARCHAR2 CHARACTER SET ch%CHARSET;
 38      pragma interface (c,pesxcp);
 39
 40  -- end of NLS icds
 41
 42  -- begin trusted icds
 43  -- Comparisons
 44  -- Conversions
 45  --  function peslts(label MLSLABEL,format VARCHAR2) return VARCHAR2;
 46  --    pragma interface (c,peslts);
 47  --  function pesstl(label varchar2,format VARCHAR2) return MLSLABEL;
 48  --    pragma interface (c,pesstl);
 49  -- end trusted icds
 50  -----------------------------------------------------------
 51
 52    -- Body for sqlerrm. Not necessary, since COG special-cases this flavor
 53    -- of sqlerrm, and never actually calls the body. But the body is required
 54    -- because the spec has no pragma builtin or interface on it. So just whine
 55    -- if this is ever called
 56    function sqlerrm return varchar2 is
 57    begin
 58      RAISE program_error;
 59      return NULL;
 60    end sqlerrm;
 61
 62    function pessdx (ch VARCHAR2 CHARACTER SET ANY_CS)
 63          return VARCHAR2 CHARACTER SET ch%CHARSET;
 64      pragma interface (c,pessdx);
 65
 66    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
 67    -- the old 'select soundex(...) from dual;' thing.  This allows us to do the
 68    -- SELECT from PL/SQL rather than having to do it from C (within the ICD.)
 69    function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
 70          return VARCHAR2 CHARACTER SET ch%CHARSET is
 71      c VARCHAR2(2000) CHARACTER SET ch%CHARSET;
 72    begin
 73      c := pessdx(ch);
 74      return c;
 75    exception
 76      when ICD_UNABLE_TO_COMPUTE then
 77        select soundex(ch) into c from sys.dual;
 78        return c;
 79    end SOUNDEX;
 80
 81    function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
 82                       SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
 83                       DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
 84          return VARCHAR2 CHARACTER SET STR1%CHARSET is
 85    begin
 86      if str1 is null then return str1; else
 87          -- The substr and concat in arg list to pesxlt is done to
 88          -- allocate a modifiable COPY of the first arg, STR1. This
 89          -- operation is a complete cheat, because we pass the copy
 90          -- as an IN parm, and modify it on the sly.
 91      return pesxlt(STR1, substr(str1,1,1) || substr(str1,2),
 92                             SRC, DEST);
 93      end if;
 94    end TRANSLATE;
 95
 96   function 'IS NAN' (N NUMBER) RETURN BOOLEAN is
 97   begin
 98     if N IS NULL then
 99       return NULL;
100     else
101       return FALSE;
102     end if;
103   end 'IS NAN';
104
105   function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN is
106   begin
107     if N IS NULL then
108       return NULL;
109     else
110       return TRUE;
111     end if;
112   end 'IS NOT NAN';
113
114   function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER is
115   begin
116     return (n1);
117   end NANVL;
118
119   function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT is
120   begin
121     if f1 is nan then return (f2); else return (f1); end if;
122   end NANVL;
123
124   function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE is
125   begin
126     if d1 is nan then return (d2); else return (d1); end if;
127   end NANVL;
128
129   function TO_DATE(LEFT NUMBER, RIGHT VARCHAR2) return DATE IS
130   begin
131     return (TO_DATE(TO_char(LEFT), RIGHT));
132   end TO_DATE;
133
134    -- Bug 27091470: Calling SYS_CONTEXT results in a considerable
135    -- speed-up as opposed to directly calling SQL like before.
136    -- If for some reason, the ICD cannot be called, then SYS_CONTEXT
137    -- will draw upon SQL's routine. This change is applied to UID
138    -- and USER.
139
140    function UID return PLS_INTEGER is
141    begin
142          return SYS_CONTEXT('USERENV', 'SESSION_USERID');
143    end;
144
145    function USER return varchar2 is
146    begin
147          return SYS_CONTEXT('USERENV', 'SESSION_USER');
148    end;
149
150
151    function pesuen(envstr VARCHAR2) return VARCHAR2;
152      pragma interface (c,pesuen);
153
154    -- Bug 27091470: In order to get this function to execute faster, the
155    -- pesuen() ICD is in progress of being deprecated, as SYS_CONTEXT features
156    -- a cleaner and faster execution. In case the ICD is unavailable,
157    -- SYS_CONTEXT will call SQL like before. There are exceptions to this rule,
158    -- of course:
159    --    * ENTRYID: In the case pesuen() returns '0', SYS_CONTEXT returns NULL.
160    --               This difference is currently being investigated.
161    --
162    --    * SCHEMAID: This case runs all right. It's not included within the 'IN'
163    --                clause, as the SYS_CONTEXT parameter is named differently.
164    --
165    --    * PID: We have not found whether it's possible to get this value by
166    --           means of SYS_CONTEXT.
167    --
168    -- Partially deprecated: Only ENTRYID and PID still call pesuen() ICD and
169    -- if an exception is raised, then SQL. The rest have been moved to
170    -- calling SYS_CONTEXT.
171    --
172    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
173    -- the old 'select userenv(...) from dual;' thing.  This allows us to do the
174    -- select from PL/SQL rather than having to do it from C (within the ICD.)
175    function USERENV (envstr varchar2) return varchar2 is
176    c varchar2(255);
177    begin
178      if envstr is null then
179        raise INVALID_USERENV_PARAMETER;
180      end if;
181      c := upper(envstr);
182
183      -- The comment below refers to a partially deprecated functionality. It
184      -- is still applied to only ENTRYID and PID parameters.
185
186      -- Gaak: we can't replace the following with a single block of code based
187      -- around 'USERENV(c)' because passing USERENV() anything but a string
188      -- literal parameter result in ORA-2003: Invalid USERENV parameter!  This
189      -- also means that we must manually update this file whenever RDBMS adds a
190      -- new option.
191      if c = 'COMMITSCN' then
192        raise USERENV_COMMITSCN_ERROR;
193      elsif c in ('TERMINAL', 'SESSIONID', 'LANGUAGE', 'LANG',
194                  'INSTANCE', 'CLIENT_INFO', 'ISDBA', 'SID') then
195        c := SYS_CONTEXT('USERENV', c);
196      elsif c = 'ENTRYID' then
197        begin
198          c := pesuen(c);
199        exception
200          when ICD_UNABLE_TO_COMPUTE then
201            select userenv('ENTRYID') into c from sys.dual;
202        end;
203      elsif c = 'SCHEMAID' then
204        c := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMAID');
205      elsif c = 'PID' then
206        begin
207          c := pesuen(c);
208        exception
209          when ICD_UNABLE_TO_COMPUTE then
210            select userenv('PID') into c from sys.dual;
211        end;
212      else
213        raise INVALID_USERENV_PARAMETER;
214      end if;
215      return c;
216    end;
217
218  -- Trusted*Oracle additions
219
220    Function ROWLABEL return MLSLABEL is
221          begin return null; end;
222  -- removed - now builtin's
223
224  --  Function TO_CHAR(label MLSLABEL, format varchar2 := '')
225  --       return VARCHAR2 is
226  --    begin return peslts(label,format); end;
227  --
228  --  Function TO_LABEL(label varchar2, format varchar2 := '')
229  --       return MLSLABEL is
230  --    begin return pesstl(label,format); end;
231
232  -- group functions
233    Function LUB (label MLSLABEL) return MLSLABEL is
234          begin return null; end;
235    Function GLB (label MLSLABEL) return MLSLABEL is
236          begin return null; end;
237
238  -- end of Trusted*Oracle additions
239
240
241  -- beginning of NLS routines
242  -- replaced with new versions 6/3/92 JEM
243
244    function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW is
245    begin
246      return pesxco(c,'');
247    end NLSSORT;
248
249    function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
250          return VARCHAR2 CHARACTER SET ch%CHARSET is
251    begin
252      return pesxup(ch,'');
253    end NLS_UPPER;
254
255    function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
256          return VARCHAR2 CHARACTER SET ch%CHARSET is
257    begin
258      return pesxlo(ch,'');
259    end NLS_LOWER;
260
261    function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
262          return VARCHAR2 CHARACTER SET ch%CHARSET is
263    begin
264      return pesxcp(ch,'');
265    end NLS_INITCAP;
266
267
268
269    function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
270      return PLS_INTEGER is
271     i PLS_INTEGER;
272    begin
273     select nls_charset_decl_len(bytecnt, csetid) into i from sys.dual;
274     return i;
275    end NLS_CHARSET_DECL_LEN;
276  -- end of NLS routines
277
278
279  -- DUMP and VSIZE are now not allowed in non-sql plsql, has code to forbid
280  -- it there, and is defined as a builtin in stdspc. The body will not be
281  -- called in plsql.
282  --- CMB
283  ----
284  -- dump
285  -- dump( expr [,display_format[,start_pos[,length]]]) return varchar2
286  -- how large should the plsql varchar2 string be
287  --
288
289  -- why do we need these dummy bodies for LEVEL and ROWNUM?
290
291    function LEVEL return NUMBER is
292          begin return 0.0; end;
293
294    function ROWNUM return NUMBER is
295          begin return 0.0; end;
296
297  --
298  -- ACOS, ASIN, ATAN, ATAN2
299  --   These functions return NULL if any of the inputs are NULL
300  --
301    function pesacos(n NUMBER) return NUMBER;
302      pragma interface (c,pesacos);
303
304    function pesasin(n NUMBER) return NUMBER;
305      pragma interface (c,pesasin);
306
307    function pesatn2(x NUMBER, y NUMBER) return NUMBER;
308      pragma interface (c,pesatn2);
309
310    function ACOS(n NUMBER) return NUMBER is
311    begin
312      if (n > 1) or (n < -1) then raise VALUE_ERROR; end if;
313      return pesacos(n);
314    end ACOS;
315
316    function ASIN(n NUMBER) return NUMBER is
317    begin
318      if (n > 1) or (n < -1) then raise VALUE_ERROR; end if;
319      return pesasin(n);
320    end ASIN;
321
322    function ATAN2(x NUMBER, y NUMBER) return NUMBER is
323    begin
324      if ((x = 0) and (y = 0)) then raise VALUE_ERROR; end if;
325      return pesatn2(x, y);
326    end ATAN2;
327
328  --****************************************************************
329
330    -- This body is required, and will be called
331    function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
332          return "<REF_CURSOR_1>" is
333    begin
334      if (B1 IS NULL) then return(B2); else return(B1); end if;
335    end NVL;
336
337    /* these are special internal functions
338       they are potential dangerous and not to be used by customers */
339    function "SYS$LOB_REPLICATION" (x in blob) return blob
340          is begin return x; end;
341    function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
342      return clob character set x%charset
343    is begin return x; end;
344
345    --  Generic SQL DDL routine
346    --
347    --  This used to use plzopn, plzosq, etc. declared above;  now we use a
348    --  single bundled call.  Move these defs here so new ICD will not disturb
349    --  the ordering of the list.
350
351    FUNCTION plzsql(stmt VARCHAR2) RETURN binary_integer;
352    PRAGMA interface (c,plzsql);
353
354    procedure SQL_DDL(Stmt VARCHAR2) is
355           rc Binary_Integer;
356           DDL_ERROR exception;
357    Begin
358           rc := plzsql(Stmt);
359           if ( rc IS NOT NULL ) then
360                  RAISE DDL_ERROR;
361           end if;
362    End;
363
364    --  SQL Transaction routines
365
366    procedure SET_TRANSACTION_USE (vc varchar2) is
367    Begin
368           SQL_DDL('SET TRANSACTION USE ROLLBACK SEGMENT ' || vc);
369    End;
370
371    procedure COMMIT is
372    Begin
373           SQL_DDL('COMMIT');
374    End;
375
376    procedure COMMIT_CM (vc varchar2) is
377    Begin
378      -- bug13944958:
379      -- COMMIT_CM procedure takes the input argument "vs" as the comment string
380      -- to execute the SQL DDL "COMMIT work comment 'vc'" statement.
381      -- The input comment string to the COMMIT statement is vulnerable to
382      -- SQL injection because it may contain single-quotes.
383      -- Before we manually quote the comment string, we need to escape any
384      -- embedded quotes first.
385      SQL_DDL('COMMIT work comment ' || '''' ||
386              replace(vc, '''', '''''') || '''');
387    End;
388
389    procedure ROLLBACK_NR is
390    Begin
391           SQL_DDL('ROLLBACK');
392    End;
393
394    procedure ROLLBACK_SV(Save_Point CHAR) is
395    Begin
396           SQL_DDL('ROLLBACK TO ' || Save_Point);
397    End;
398
399    procedure SAVEPOINT(Save_Point CHAR) is
400    begin
401           SQL_DDL('SAVEPOINT ' || Save_Point);
402    end;
403
404
405  ------ Datetime code starts here ------
406
407
408  -- functions to create intervals from constituent parts.
409
410    function pesn2ymi(numerator number, units number)
411      return yminterval_unconstrained;
412    pragma interface (c,pesn2ymi);
413    function pesn2dsi(numerator number, units number)
414       return dsinterval_unconstrained;
415    pragma interface (c,pesn2dsi);
416
417   function NUMTOYMINTERVAL(numerator number, units varchar2 character set any_cs)
418       return yminterval_unconstrained
419       IS unitno NUMBER := 0;
420          unitstr VARCHAR2(5) character set units%charset := upper(trim(units));
421       begin
422       IF (unitstr = 'YEAR')  THEN unitno := 1;
423       elsif (unitstr = 'MONTH') THEN unitno := 2;
424       END IF;
425       return pesn2ymi(numerator,unitno);
426       -- IF unitno := 0 core will RAISE correct error
427       end;
428
429   function NUMTODSINTERVAL(numerator number, units varchar2 character set any_cs)
430       return dsinterval_unconstrained
431       IS unitno NUMBER := 0;
432          unitstr VARCHAR2(6) character set units%charset := upper(trim(units));
433       begin
434       IF (unitstr = 'DAY') THEN  unitno := 1;
435       elsif (unitstr = 'HOUR') THEN unitno := 2;
436       elsif (unitstr = 'MINUTE') THEN  unitno := 3;
437       elsif (unitstr = 'SECOND') THEN unitno := 4;
438       END IF;
439       return pesn2dsi(numerator,unitno);
440       -- IF unitno = 0 core will RAISE correct error
441       end;
442
443    function pessdt return DATE;
444      pragma interface (c,pessdt);
445
446    -- Bug 1287775: back to calling ICD.
447    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
448    -- the old 'SELECT SYSDATE FROM DUAL;' thing.  This allows us to do the
449    -- SELECT from PL/SQL rather than having to do it from C (within the ICD.)
450    function sysdate return date is
451      d date;
452    begin
453      d := pessdt;
454      return d;
455    exception
456      when ICD_UNABLE_TO_COMPUTE then
457        select sysdate into d from sys.dual;
458        return d;
459    end;
460
461    function pesguid return RAW;
462      pragma interface (c,pesguid);
463
464    function SYS_GUID return raw is
465      c raw(16);
466    begin
467      c := pesguid;
468      return c;
469    exception
470      when ICD_UNABLE_TO_COMPUTE then
471          select sys_guid() into c from sys.dual;
472          return c;
473    end;
474
475    function pessysctx2(namespace varchar2, attribute varchar2) return varchar2;
476      pragma interface (c,pessysctx2);
477
478    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
479    -- the old 'select sys_context(...) from dual;' thing.  This allows us to do
480    -- the select from PL/SQL rather than having to do it from C (within the ICD.)
481    function SYS_CONTEXT(namespace varchar2, attribute varchar2)
482      return varchar2 is
483    c varchar2(4000);
484    BEGIN
485      c := pessysctx2(namespace, attribute);
486      return c;
487    exception
488      when ICD_UNABLE_TO_COMPUTE then
489        select sys_context(namespace,attribute) into c from sys.dual;
490        return c;
491    end;
492
493  -- time zone functions
494
495    function pessts return timestamp_tz_unconstrained;
496      pragma interface (c,pessts);
497
498    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
499    -- the old 'SELECT systimestamp FROM dual;' thing.  This allows us to do the
500    -- SELECT from PL/SQL rather than having to do it from C (within the ICD.)
501    FUNCTION systimestamp RETURN timestamp_tz_unconstrained
502    IS  t timestamp_tz_unconstrained;
503    BEGIN
504      t := pessts;
505      RETURN t;
506    EXCEPTION
507      WHEN ICD_UNABLE_TO_COMPUTE THEN
508        SELECT systimestamp INTO t FROM sys.dual;
509        RETURN t;
510    END;
511
512    function pesdbtz return varchar2;
513      pragma interface (c,pesdbtz);
514
515    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
516    -- the old 'SELECT dbtimezone FROM dual;' thing.  This allows us to do the
517    -- SELECT from PL/SQL rather than having to do it from C (within the ICD.)
518    FUNCTION dbtimezone RETURN varchar2
519    IS  t VARCHAR2(75);                                -- == TZNMSTRLEN [2213965]
520    BEGIN
521      t := pesdbtz;
522      RETURN t;
523    EXCEPTION
524      WHEN ICD_UNABLE_TO_COMPUTE THEN
525        SELECT dbtimezone INTO t FROM sys.dual;
526        RETURN t;
527    END;
528
529    FUNCTION localtimestamp RETURN timestamp_unconstrained
530    IS t timestamp_tz_unconstrained := current_timestamp;
531    BEGIN
532     RETURN (cast(t AS timestamp_unconstrained));
533    END;
534
535    FUNCTION localtime RETURN time_unconstrained
536    IS t time_tz_unconstrained := current_time;
537    BEGIN
538     RETURN (cast(t AS time_unconstrained));
539    END;
540
541    function pessysctx3(namespace varchar2, attribute varchar2,
542                        newoptional varchar2) return varchar2;
543      pragma interface (c,pessysctx3);
544
545    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
546    -- the old 'select sys_context(...) from dual;' thing.  This allows us to do
547    -- the select from PL/SQL rather than having to do it from C (within the ICD.)
548    function SYS_CONTEXT(namespace varchar2, attribute varchar2,
549                         newoptional varchar2)
550      return varchar2 is
551    c varchar2(4000);
552    BEGIN
553      c := pessysctx3(namespace, attribute, newoptional);
554      return c;
555    exception
556      when ICD_UNABLE_TO_COMPUTE then
557        select sys_context(namespace,attribute,newoptional) into c from sys.dual;
558        return c;
559    end;
560
561    function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB is
562    begin
563      return cl;
564    end;
565    function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB is
566    begin
567      return cl;
568    end;
569
570    function NCHR(n INTEGER) return NVARCHAR2 is
571    begin
572      return CHR(n using NCHAR_CS);
573    end;
574      function pescsetname(csetid PLS_INTEGER) return varchar2;
575    pragma interface (c, pescsetname);
576
577    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
578    -- the old 'select nls_charset_name(...) from dual;' thing.  This allows us to do
579    -- the select from PL/SQL rather than having to do it from C (within the ICD.)
580    function NLS_CHARSET_NAME(csetid PLS_INTEGER)
581      return VARCHAR2 is
582     v varchar2(2000);
583    begin
584     v := pescsetname(csetid);
585     return v;
586    exception
587      when ICD_UNABLE_TO_COMPUTE then
588        select nls_charset_name(csetid) into v from sys.dual;
589        return v;
590    end NLS_CHARSET_NAME;
591
592
593    function pescsetid(csetname VARCHAR2) return pls_integer;
594    pragma interface (c, pescsetid);
595
596    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
597    -- the old 'select nls_charset_id(...) from dual;' thing.  This allows us to do
598    -- the select from PL/SQL rather than having to do it from C (within the ICD.)
599    function NLS_CHARSET_ID(csetname VARCHAR2)
600      return PLS_INTEGER is
601     i PLS_INTEGER;
602    begin
603      i := pescsetid(csetname);
604      return i;
605
606      exception
607         when ICD_UNABLE_TO_COMPUTE then
608            select nls_charset_id(csetname) into i from sys.dual;
609            return i;
610    end NLS_CHARSET_ID;
611  -- REFs of opaque types are not yet supported.
612  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
613  --         return REF "<OPAQUE_1>" is
614  --  begin
615  --    if (B1 IS NULL) then return(B2); else return(B1); end if;
616  --  end NVL;
617
618
619  -- END OF PACKAGE standard
620  end;
621
622
623
624  /

Package body created.

Elapsed: 00:00:00.41
SQL> @?/rdbms/admin/sqlsessend.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/sqlsessend.sql /main/3 2018/07/25 13:50:02 surman Exp $
SQL> Rem
SQL> Rem sqlsessend.sql
SQL> Rem
SQL> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      sqlsessend.sql - SQL session end
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Any commands which should be run at the end of all oracle
SQL> Rem      supplied scripts.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      See sqlsessstart.sql for the corresponding start script.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessend.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessend.sql
SQL> Rem    SQL_PHASE: MISC
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    surman      03/08/13 - 16462837: Common start and end scripts
SQL> Rem    surman      03/08/13 - Created
SQL> Rem
SQL>
SQL> alter session set "_ORACLE_SCRIPT" = false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL>
SQL> grant execute on STANDARD to public;

Grant succeeded.

Elapsed: 00:00:01.60
SQL> @?/rdbms/admin/sqlsessend.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/sqlsessend.sql /main/3 2018/07/25 13:50:02 surman Exp $
SQL> Rem
SQL> Rem sqlsessend.sql
SQL> Rem
SQL> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      sqlsessend.sql - SQL session end
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Any commands which should be run at the end of all oracle
SQL> Rem      supplied scripts.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      See sqlsessstart.sql for the corresponding start script.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessend.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessend.sql
SQL> Rem    SQL_PHASE: MISC
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    surman      03/08/13 - 16462837: Common start and end scripts
SQL> Rem    surman      03/08/13 - Created
SQL> Rem
SQL>
SQL> alter session set "_ORACLE_SCRIPT" = false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL>
SQL> @@&dbmsstdx
SQL> rem
SQL> rem $Header: rdbms/admin/dbmsstdx.sql /main/32 2015/02/15 21:52:00 sylin Exp $
SQL> rem
SQL> Rem Copyright (c) 1991, 2015, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem    NAME
SQL> Rem      stdext.sql - Kernel extensions to package standard
SQL> Rem    DESCRIPTION
SQL> Rem      Routines in this package do not need to be qualified by the
SQL> Rem      owner or package name, similar to the behaviour of package
SQL> Rem      'standard'.  This package mostly contains utility routines for
SQL> Rem      triggers.
SQL> Rem    RETURNS
SQL> Rem
SQL> Rem    NOTES
SQL> Rem
SQL> Rem
SQL> Rem BEGIN SQL_FILE_METADATA
SQL> Rem SQL_SOURCE_FILE: rdbms/admin/dbmsstdx.sql
SQL> Rem SQL_SHIPPED_FILE: rdbms/admin/dbmsstdx.sql
SQL> Rem SQL_PHASE: DBMSSTDX
SQL> Rem SQL_STARTUP_MODE: NORMAL
SQL> Rem SQL_IGNORABLE_ERRORS: NONE
SQL> Rem SQL_CALLING_FILE: rdbms/admin/cdstrt.sql
SQL> Rem END SQL_FILE_METADATA
SQL> Rem
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem     sylin      01/22/15  - 20387919: add ora_max_name_len_supported
SQL> Rem     traney     12/04/14  - 41716: long identifiers
SQL> Rem     surman     12/29/13  - 13922626: Update SQL metadata
SQL> Rem     rpang      07/23/12  - 14362485: add original_sql_txt
SQL> Rem     surman     03/27/12  - 13615447: Add SQL patching tags
SQL> Rem     lvbcheng   01/13/11  - 128: dbms_id and dbms_quoted_id
SQL> Rem     dalpern    03/17/09  - bug 7646876: applying_crossedition_trigger
SQL> Rem     sagrawal   05/15/06  - sys_GetTriggerState
SQL> Rem     gviswana   05/24/01  - CREATE OR REPLACE SYNONYM
SQL> Rem     ykunitom   04/04/01  - fix bug 1473966
SQL> Rem     weiwang    05/02/00  - add error functions
SQL> Rem     najain     04/25/00  - add partition_pos function
SQL> Rem     najain     04/14/00  - add sqltext attr. func
SQL> Rem     weiwang    02/28/00 -  fix bug 1209532
SQL> Rem     weiwang    08/02/99 -  change name_list_t to ora_name_list_t
SQL> Rem     weiwang    02/09/99 -  add isdropcolumn, isaltercolumn
SQL> Rem     weiwang    09/15/98 -  add function des_encrypted_password
SQL> Rem     weiwang    06/11/98 -  add function dictionary_obj_owner
SQL> Rem     jkrishna   05/05/98 -  support for error events
SQL> Rem     jkrishna   04/01/98 -  adding system event callouts
SQL> Rem     cbarclay   11/06/96 -  remove kkxl*em
SQL> Rem     mmonajje   09/16/96 -  Fixing bug 244014; Adding RESTRICT_REFERENCES pr
SQL> Rem     ramkrish   06/28/96 -  Add EMPTY_BLOB, EMPTY_CLOB routines
SQL> Rem     hjakobss   10/16/94 -  bug 151485 - remove sql_ddl
SQL> Rem     jwijaya    04/05/93 -  merge changes from branch 1.3.312.1
SQL> Rem     jwijaya    03/26/93 -  bug 157348
SQL> Rem     rkooi      11/28/92 -  add 'keep' option to raise_application_error
SQL> Rem     rkooi      10/25/92 -  deal with null arg to rae
SQL> Rem     glumpkin   10/21/92 -  Renamed from STDEXT.SQL
SQL> Rem     mmoore     09/24/92 - #(130568) add callback for commit comment
SQL> Rem     rkooi      09/02/92 -  change pls_integer to binary_integer
SQL> Rem     mmoore     08/12/92 -  override the savepoint command in standard
SQL> Rem     rkooi      06/10/92 -  add 'do not change' comment
SQL> Rem     mmoore     04/14/92 -  move begin_oltp to package transaction
SQL> Rem     rkooi      04/06/92 -  merge changes from branch 1.7.300.1
SQL> Rem     rkooi      04/02/92 -  split dbms_standard into separate pkgs
SQL> Rem     maporter   03/25/92 -  renumber 8200 to 8175
SQL> Rem     rbamford   03/07/92 -  add BEGIN_OLTP_TRANSACTION
SQL> Rem     mroberts   02/21/92 -  delete extra rollback_sv procedure
SQL> Rem     rkooi      02/17/92 -  add set_role and related procedures
SQL> Rem     mroberts   02/14/92 -  add execute_ddl internal
SQL> Rem     mmoore     02/06/92 -  change name of package
SQL> Rem     mmoore     01/14/92 -  add rollback_nr
SQL> Rem     mmoore     01/09/92 -  speed up
SQL> Rem      rkooi      11/24/91 -  rename to stdext.sql from stdext.pls
SQL> Rem      rkooi      08/26/91 -  get rid of stack_application_error
SQL> Rem      rkooi      05/08/91 -  change name to standard_extension
SQL> Rem      rkooi      05/02/91 -  forgot skip_row procedure
SQL> Rem      mmoore     05/02/91 -  move trigger icds to psd, use varchar2 in
SQL> Rem                             rae/sae
SQL> Rem      rkooi      04/23/91 -  add 'skip_row' procedure, commit etc.
SQL> Rem                             procedures.
SQL> Rem      Moore      04/02/91 -  fix typo
SQL> Rem      Moore      03/28/91 -  add boolean trigger functions
SQL> Rem      Kooi       03/17/91 -  Creation
SQL> Rem      Kooi       03/12/91 -  change name to standard_utilities
SQL> Rem      Kooi       02/26/91 -  get rid of raise now that psdkse does it
SQL> Rem      Kooi       02/26/91 -  Creation
SQL> ------------------------------------------------------------------------------
SQL>
SQL> @@?/rdbms/admin/sqlsessstart.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/sqlsessstart.sql /main/3 2018/07/25 13:50:02 surman Exp $
SQL> Rem
SQL> Rem sqlsessstart.sql
SQL> Rem
SQL> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      sqlsessstart.sql - SQL session start
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Any commands which should be run at the start of all oracle
SQL> Rem      supplied scripts.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      See sqlsessend.sql for the corresponding end script.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessstart.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessstart.sql
SQL> Rem    SQL_PHASE: MISC
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    surman      03/08/13 - 16462837: Common start and end scripts
SQL> Rem    surman      03/08/13 - Created
SQL> Rem
SQL>
SQL> alter session set "_ORACLE_SCRIPT" = true;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> REM *****************************************************************
SQL> REM THIS PACKAGE MUST NOT BE MODIFIED BY THE CUSTOMER.  DOING SO
SQL> REM COULD CAUSE INTERNAL ERRORS AND SECURITY VIOLATIONS IN THE RDBMS.
SQL> REM *****************************************************************
SQL>
SQL> create or replace package dbms_standard is
  2
  3    -- constant defines maximum name length possible
  4    ORA_MAX_NAME_LEN constant pls_integer := 128;
  5
  6    -- types
  7     type ora_name_list_t is table of varchar2(2*(ORA_MAX_NAME_LEN+2)+1);
  8
  9    -- DBMS_ID and DBMS_QUOTED_ID define the length of identifiers
 10    -- in objects for SQL, PL/SQL and users.
 11     subtype dbms_id is varchar2(ORA_MAX_NAME_LEN);
 12     subtype dbms_quoted_id is varchar2(ORA_MAX_NAME_LEN+2);
 13
 14     subtype dbms_id_30 is varchar2(30);
 15     subtype dbms_quoted_id_30 is varchar2(32);
 16     subtype dbms_id_128 is varchar2(ORA_MAX_NAME_LEN);
 17     subtype dbms_quoted_id_128 is varchar2(ORA_MAX_NAME_LEN+2);
 18
 19    -- Trigger Operations
 20    procedure raise_application_error(num binary_integer, msg varchar2,
 21        keeperrorstack boolean default FALSE);
 22      pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
 23      pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
 24    function inserting return boolean;
 25      pragma interface (C, inserting);                       -- 2
 26      pragma restrict_references (inserting, WNPS, RNPS, WNDS);
 27    function deleting  return boolean;
 28      pragma interface (C, deleting);                        -- 3
 29      pragma restrict_references (deleting, WNPS, RNPS, WNDS);
 30    function updating  return boolean;
 31      pragma interface (C, updating);                        -- 4
 32      pragma restrict_references (updating, WNPS, RNPS, WNDS);
 33    function updating (colnam varchar2) return boolean;
 34      pragma interface (C, updating);                        -- 5
 35      pragma restrict_references (updating, WNPS, RNPS, WNDS);
 36
 37    -- Transaction Commands
 38    procedure commit;
 39      pragma interface (C, commit);                          -- 6
 40    procedure commit_cm(vc varchar2);
 41      pragma interface (C, commit_cm);                       -- 7
 42    procedure rollback_nr;
 43      pragma interface (C, rollback_nr);                     -- 8
 44    procedure rollback_sv(save_point varchar2);
 45      pragma interface (C, rollback_sv);                     -- 9
 46    procedure savepoint(save_point varchar2);
 47      pragma interface (C, savepoint);                       -- 10
 48    procedure set_transaction_use(vc varchar2);
 49      pragma interface (C, set_transaction_use);             -- 11
 50
 51
 52    -- Functions supported for system events
 53    -- Null or zero will be returned if called in inappropriate occasions
 54    -- error functions only search for the top 5 errors in the error stack
 55
 56    function sysevent return varchar2 ;                      -- 12
 57      pragma interface (C, sysevent);
 58      pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
 59    function dictionary_obj_type return varchar2 ;           -- 13
 60      pragma interface (C, dictionary_obj_type);
 61      pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
 62     function dictionary_obj_owner return varchar2 ;           -- 14
 63      pragma interface (C, dictionary_obj_owner);
 64      pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
 65    function dictionary_obj_name return varchar2 ;           -- 15
 66      pragma interface (C, dictionary_obj_name);
 67      pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
 68    function database_name return varchar2 ;                 -- 16
 69      pragma interface (C, database_name);
 70      pragma restrict_references (database_name, WNPS, RNPS, WNDS);
 71    function instance_num return binary_integer ;            -- 17
 72      pragma interface (C, instance_num);
 73      pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
 74    function login_user return varchar2 ;                    -- 18
 75      pragma interface (C, login_user);
 76      pragma restrict_references (login_user, WNPS, RNPS, WNDS);
 77    function is_servererror (errno binary_integer)
 78                  return boolean ;                           -- 19
 79      pragma interface (C, is_servererror);
 80      pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);
 81
 82    function server_error(position binary_integer)
 83                          return binary_integer ;           -- 20
 84      pragma interface (C, server_error);
 85      pragma restrict_references (server_error, WNPS, RNPS, WNDS);
 86    function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
 87      pragma interface (C, des_encrypted_password);
 88      pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
 89    function is_alter_column (column_name varchar2)
 90                  return boolean ;                           -- 22
 91      pragma interface (C, is_alter_column);
 92      pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
 93    function is_drop_column (column_name varchar2)
 94                  return boolean ;                           -- 23
 95      pragma interface (C, is_drop_column);
 96      pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
 97    function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
 98      pragma interface (C, grantee);
 99      pragma restrict_references (grantee, WNPS, RNPS, WNDS);
100    function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
101      pragma interface (C, revokee);
102      pragma restrict_references (revokee, WNPS, RNPS, WNDS);
103    function privilege_list (priv_list out ora_name_list_t)
104                  return binary_integer ;                    -- 26
105      pragma interface (C, privilege_list);
106      pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
107    function with_grant_option return boolean ;                    -- 27
108      pragma interface (C, with_grant_option);
109      pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
110    function dictionary_obj_owner_list (owner_list out ora_name_list_t)
111                  return binary_integer;                           -- 28
112      pragma interface (C, dictionary_obj_owner_list);
113      pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
114    function dictionary_obj_name_list (object_list out ora_name_list_t)
115                  return binary_integer;                           -- 29
116      pragma interface (C, dictionary_obj_name_list);
117      pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
118    function is_creating_nested_table return boolean;              -- 30
119      pragma interface (C, is_creating_nested_table);
120      pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
121    function client_ip_address return varchar2;                    -- 31
122      pragma interface (C, client_ip_address);
123      pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
124    function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
125      pragma interface (C, sql_txt);
126      pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
127    function server_error_msg (position binary_integer) return varchar2; -- 33
128      pragma interface (C, server_error_msg);
129      pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
130    function server_error_depth return binary_integer;              -- 34
131      pragma interface (C, server_error_depth);
132      pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
133    function server_error_num_params (position binary_integer)
134                                     return binary_integer;         -- 35
135      pragma interface (C, server_error_num_params);
136      pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
137    function server_error_param(position binary_integer, param binary_integer)
138                                return varchar2;                    -- 36
139      pragma interface (C, server_error_param);
140      pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
141    function partition_pos return binary_integer;                  -- 37
142      pragma interface (C, partition_pos);
143      pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);
144
145    function sys_GetTriggerState  return pls_integer;
146      pragma interface (C, Sys_GetTriggerState);                        -- 38
147      pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
148    function applying_crossedition_trigger return boolean;
149      pragma interface (C, applying_crossedition_trigger);              -- 39
150      pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
151
152    function original_sql_txt (sql_text out ora_name_list_t)
153             return binary_integer;                                     -- 40
154      pragma interface (C, original_sql_txt);
155      pragma restrict_references (original_sql_txt, WNPS, RNPS, WNDS);
156
157  /*-----------------------------------------------------------------------------
158    Function: return maximum name length supported
159      If compatible >= 12.2.0.0, returns 128.
160      If compatible < 12.2.0.0, returns 30.
161   */
162
163    function ora_max_name_len_supported return pls_integer;
164      pragma interface (C, ora_max_name_len_supported);
165  end;
166  /

Package created.

Elapsed: 00:00:00.32
SQL>
SQL> create or replace public synonym dbms_standard for sys.dbms_standard
  2  /

Synonym created.

Elapsed: 00:00:00.22
SQL> grant execute on dbms_standard to public
  2  /

Grant succeeded.

Elapsed: 00:00:00.01
SQL>
SQL> @?/rdbms/admin/sqlsessend.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/sqlsessend.sql /main/3 2018/07/25 13:50:02 surman Exp $
SQL> Rem
SQL> Rem sqlsessend.sql
SQL> Rem
SQL> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      sqlsessend.sql - SQL session end
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Any commands which should be run at the end of all oracle
SQL> Rem      supplied scripts.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      See sqlsessstart.sql for the corresponding start script.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessend.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessend.sql
SQL> Rem    SQL_PHASE: MISC
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    surman      03/08/13 - 16462837: Common start and end scripts
SQL> Rem    surman      03/08/13 - Created
SQL> Rem
SQL>
SQL> alter session set "_ORACLE_SCRIPT" = false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL>
SQL> alter session set "_force_standard_compile"=FALSE;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- Step (III)
SQL> --
SQL> -- Invalidate views and synonyms which depend (directly or indirectly) on
SQL> -- invalid objects.
SQL> begin
  2    loop
  3      update obj$ o_outer set status = 6
  4      where     type# in (4, 5)
  5            and status not in (5, 6)
  6            and linkname is null
  7            and ((subname is null) or (subname <> 'DBMS_DBUPGRADE_BABY'))
  8            and exists (select o.obj# from obj$ o, dependency$ d
  9                        where     d.d_obj# = o_outer.obj#
 10                              and d.p_obj# = o.obj#
 11                              and (bitand(d.property, 1) = 1)
 12                              and o.status > 1) &andorclsupp;
 13      exit when sql%notfound;
 14    end loop;
 15  end;
 16  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14
SQL>
SQL> commit;

Commit complete.

Elapsed: 00:00:00.00
SQL>
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.04
SQL>
SQL> -- Step (IV)
SQL> --
SQL> -- Delete Diana for tables, views, and sequences
SQL> --
SQL> -- The DELETEs are coded in chunks using a PL/SQL loop to avoid running
SQL> -- into rollback segment limits.
SQL> --
SQL> begin
  2
  3     loop
  4        delete from idl_ub1$ where
  5           obj# in (select o.obj# from obj$ o where o.type# in (2, 4, 6))
  6           and rownum < 5000;
  7        exit when sql%rowcount = 0;
  8        commit;
  9     end loop;
 10
 11     --
 12     -- IDL_UB2$ must use dynamic SQL because its PIECE type is not
 13     -- understood by PL/SQL.
 14     --
 15     loop
 16        execute immediate
 17           'delete from idl_ub2$ where
 18            obj# in (select o.obj# from obj$ o where o.type# in (2, 4, 6))
 19            and rownum < 5000';
 20        exit when sql%rowcount = 0;
 21        commit;
 22     end loop;
 23
 24     --
 25     -- IDL_SB4$ must use dynamic SQL because its PIECE type is not
 26     -- understood by PL/SQL.
 27     --
 28     loop
 29        execute immediate
 30           'delete from idl_sb4$ where
 31            obj# in (select o.obj# from obj$ o where o.type# in (2, 4, 6))
 32            and rownum < 5000';
 33        exit when sql%rowcount = 0;
 34        commit;
 35     end loop;
 36
 37     loop
 38        delete from idl_char$ where
 39           obj# in (select o.obj# from obj$ o where o.type# in (2, 4, 6))
 40           and rownum < 5000;
 41        exit when sql%rowcount = 0;
 42        commit;
 43     end loop;
 44  end;
 45  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.11
SQL> commit;

Commit complete.

Elapsed: 00:00:00.00
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.04
SQL>
SQL> Rem Continue even if there are SQL errors
SQL> WHENEVER SQLERROR CONTINUE;
SQL>
SQL> Rem ===========================================================================
SQL> Rem END utlip.sql
SQL> Rem ===========================================================================
SQL>
SQL> -- explicitly compile these now, before close/reopen. Otherwise they would
SQL> -- be used/validated within PDB Open, where such patching (clearing of dict
SQL> -- rows) can't be done.
SQL> alter session set "_ORACLE_SCRIPT"=true;

Session altered.

Elapsed: 00:00:00.01
SQL> alter public synonym ALL_OBJECTS compile;

Synonym altered.

Elapsed: 00:00:01.09
SQL> alter view SYS.V_$PARAMETER compile;

View altered.

Elapsed: 00:00:00.22
SQL>
SQL> WHENEVER SQLERROR CONTINUE;
SQL> alter type SYS.ANYDATA compile;

Type altered.

Elapsed: 00:00:01.11
SQL> WHENEVER SQLERROR EXIT;
SQL>
SQL> alter session set "_ORACLE_SCRIPT"=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> alter pluggable database "&pdbname" close immediate instances=all;

Pluggable database altered.

Elapsed: 00:00:32.27
SQL> alter pluggable database "&pdbname" open restricted;

Warning: PDB altered with errors.

Elapsed: 00:00:28.87
SQL>
SQL> -- mark old version types as valid, as utlrp skips these
SQL> update sys.obj$ set status = 1
  2    where type#=13 and subname is not null and status > 1;

153 rows updated.

Elapsed: 00:00:00.52
SQL> commit;

Commit complete.

Elapsed: 00:00:00.10
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.26
SQL>
SQL> -- 26434999: set concurrent stats gathering to OFF, save original value
SQL> COLUMN concurrent NEW_VALUE concurrent
SQL> select dbms_stats.get_prefs('CONCURRENT') concurrent from dual;

CONCURRENT
--------------------------------------------------------------------------------
OFF

1 row selected.

Elapsed: 00:00:49.45
SQL> exec dbms_stats.set_global_prefs('CONCURRENT', 'OFF');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.32
SQL>
SQL> @@?/rdbms/admin/utlrp
SQL> Rem
SQL> Rem $Header: rdbms/admin/utlrp.sql /main/23 2017/03/20 12:21:12 raeburns Exp $
SQL> Rem
SQL> Rem utlrp.sql
SQL> Rem
SQL> Rem Copyright (c) 1998, 2017, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      utlrp.sql - Recompile invalid objects
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem     This script recompiles invalid objects in the database.
SQL> Rem
SQL> Rem     When run as one of the last steps during upgrade or downgrade,
SQL> Rem     this script will validate all remaining invalid objects. It will
SQL> Rem     also run a component validation procedure for each component in
SQL> Rem     the database. See the README notes for your current release and
SQL> Rem     the Oracle Database Upgrade book for more information about
SQL> Rem     using utlrp.sql
SQL> Rem
SQL> Rem     Although invalid objects are automatically re-validated when used,
SQL> Rem     it is useful to run this script after an upgrade or downgrade and
SQL> Rem     after applying a patch. This minimizes latencies caused by
SQL> Rem     on-demand recompilation. Oracle strongly recommends running this
SQL> Rem     script after upgrades, downgrades and patches.
SQL> Rem
SQL> Rem   NOTES
SQL> Rem      * This script must be run using SQL*PLUS.
SQL> Rem      * You must be connected AS SYSDBA to run this script.
SQL> Rem      * There should be no other DDL on the database while running the
SQL> Rem        script.  Not following this recommendation may lead to deadlocks.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/utlrp.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/utlrp.sql
SQL> Rem    SQL_PHASE: UTILITY
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: NONE
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    raeburns    03/09/17 - Bug 25616909: Use UTILITY for SQL_PHASE
SQL> Rem    gviswana    06/26/03 - Switch default to parallel if appropriate
SQL> Rem    gviswana    06/12/03 - Switch default back to serial
SQL> Rem    gviswana    05/20/03 - 2814808: Automatic parallelism tuning
SQL> Rem    rburns      04/28/03 - timestamps and serveroutput for diagnostics
SQL> Rem    gviswana    04/13/03 - utlrcmp.sql load -> catproc
SQL> Rem    gviswana    06/25/02 - Add documentation
SQL> Rem    gviswana    11/12/01 - Use utl_recomp.recomp_serial
SQL> Rem    rdecker     11/09/01 - ADD ALTER library support FOR bug 1952368
SQL> Rem    rburns      11/12/01 - validate all components after compiles
SQL> Rem    rburns      11/06/01 - fix invalid CATPROC call
SQL> Rem    rburns      09/29/01 - use 9.2.0
SQL> Rem    rburns      09/20/01 - add check for CATPROC valid
SQL> Rem    rburns      07/06/01 - get version from instance view
SQL> Rem    rburns      05/09/01 - fix for use with 8.1.x
SQL> Rem    arithikr    04/17/01 - 1703753: recompile object type# 29,32,33
SQL> Rem    skabraha    09/25/00 - validate is now a keyword
SQL> Rem    kosinski    06/14/00 - Persistent parameters
SQL> Rem    skabraha    06/05/00 - validate tables also
SQL> Rem    jdavison    04/11/00 - Modify usage notes for 8.2 changes.
SQL> Rem    rshaikh     09/22/99 - quote name for recompile
SQL> Rem    ncramesh    08/04/98 - change for sqlplus
SQL> Rem    usundara    06/03/98 - merge from 8.0.5
SQL> Rem    usundara    04/29/98 - creation (split from utlirp.sql).
SQL> Rem                           Mark Ramacher (mramache) was the original
SQL> Rem                           author of this script.
SQL> Rem
SQL>
SQL> Rem ===========================================================================
SQL> Rem BEGIN utlrp.sql
SQL> Rem ===========================================================================
SQL>
SQL> @@utlprp.sql 0
SQL> Rem Copyright (c) 2003, 2017, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      utlprp.sql - Recompile invalid objects in the database
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      This script recompiles invalid objects in the database.
SQL> Rem
SQL> Rem      This script is typically used to recompile invalid objects
SQL> Rem      remaining at the end of a database upgrade or downgrade.
SQL> Rem
SQL> Rem      Although invalid objects are automatically recompiled on demand,
SQL> Rem      running this script ahead of time will reduce or eliminate
SQL> Rem      latencies due to automatic recompilation.
SQL> Rem
SQL> Rem      This script is a wrapper based on the UTL_RECOMP package.
SQL> Rem      UTL_RECOMP provides a more general recompilation interface,
SQL> Rem      including options to recompile objects in a single schema. Please
SQL> Rem      see the documentation for package UTL_RECOMP for more details.
SQL> Rem
SQL> Rem    INPUTS
SQL> Rem      The degree of parallelism for recompilation can be controlled by
SQL> Rem      providing a parameter to this script. If this parameter is 0 or
SQL> Rem      NULL, UTL_RECOMP will automatically determine the appropriate
SQL> Rem      level of parallelism based on Oracle parameters cpu_count and
SQL> Rem      parallel_threads_per_cpu. If the parameter is 1, sequential
SQL> Rem      recompilation is used. Please see the documentation for package
SQL> Rem      UTL_RECOMP for more details.
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      * You must be connected AS SYSDBA to run this script.
SQL> Rem      * There should be no other DDL on the database while running the
SQL> Rem        script.  Not following this recommendation may lead to deadlocks.
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/utlprp.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/utlprp.sql
SQL> Rem    SQL_PHASE: UTILITY
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: utlrp.sql
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    thbaby      05/11/17 - Bug 26046188: disable redirection in Proxy PDB
SQL> Rem    raeburns    04/15/17 - Bug 25790192: Add SQL_METADATA
SQL> Rem    jmuller     12/09/14 - Fix bug 19728696 (sort of): clarify comments
SQL> Rem    pyam        04/08/14 - 18478064: factor out to reenable_indexes.sql
SQL> Rem    kquinn      11/01/11 - 13059165: amend 'OBJECTS WITH ERRORS' SQL
SQL> Rem    cdilling    05/15/10 - fix bug 9712478 - call local enquote_name
SQL> Rem    anighosh    02/19/09 - #(8264899): re-enabling of function based indexes
SQL> Rem                           not needed.
SQL> Rem    cdilling    07/21/08 - check bitand for functional index - bug 7243270
SQL> Rem    cdilling    01/21/08 - add support for ORA-30552
SQL> Rem    cdilling    08/27/07 - check disabled indexes only
SQL> Rem    cdilling    05/22/07 - add support for ORA-38301
SQL> Rem    cdilling    02/19/07 - 5530085 - renable invalid indexes
SQL> Rem    rburns      03/17/05 - use dbms_registry_sys
SQL> Rem    gviswana    02/07/05 - Post-compilation diagnostics
SQL> Rem    gviswana    09/09/04 - Auto tuning and diagnosability
SQL> Rem    rburns      09/20/04 - fix validate_components
SQL> Rem    gviswana    12/09/03 - Move functional-index re-enable here
SQL> Rem    gviswana    06/04/03 - gviswana_bug-2814808
SQL> Rem    gviswana    05/28/03 - Created
SQL> Rem
SQL>
SQL> SET VERIFY OFF;
SQL>
SQL> Rem Bug 26046188: In a Proxy PDB, all top-level statements are redirected to
SQL> Rem the target (PDB) of the Proxy PDB. Set underscore parameter so that
SQL> Rem automatic redirection is turned off. This is needed so that utlrp/utlprp
SQL> Rem can be used to recompile objects in Proxy PDB.
SQL> Rem
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> SELECT dbms_registry_sys.time_stamp('utlrp_bgn') as timestamp from dual;

TIMESTAMP
--------------------------------------------------------------------------------
COMP_TIMESTAMP UTLRP_BGN              2021-02-23 12:59:31

1 row selected.

Elapsed: 00:00:04.10
SQL>
SQL> DOC
DOC>   The following PL/SQL block invokes UTL_RECOMP to recompile invalid
DOC>   objects in the database. Recompilation time is proportional to the
DOC>   number of invalid objects in the database, so this command may take
DOC>   a long time to execute on a database with a large number of invalid
DOC>   objects.
DOC>
DOC>   Use the following queries to track recompilation progress:
DOC>
DOC>   1. Query returning the number of invalid objects remaining. This
DOC>      number should decrease with time.
DOC>         SELECT COUNT(*) FROM obj$ WHERE status IN (4, 5, 6);
DOC>
DOC>   2. Query returning the number of objects compiled so far. This number
DOC>      should increase with time.
DOC>         SELECT COUNT(*) FROM UTL_RECOMP_COMPILED;
DOC>
DOC>   This script automatically chooses serial or parallel recompilation
DOC>   based on the number of CPUs available (parameter cpu_count) multiplied
DOC>   by the number of threads per CPU (parameter parallel_threads_per_cpu).
DOC>   On RAC, this number is added across all RAC nodes.
DOC>
DOC>   UTL_RECOMP uses DBMS_SCHEDULER to create jobs for parallel
DOC>   recompilation. Jobs are created without instance affinity so that they
DOC>   can migrate across RAC nodes. Use the following queries to verify
DOC>   whether UTL_RECOMP jobs are being created and run correctly:
DOC>
DOC>   1. Query showing jobs created by UTL_RECOMP
DOC>         SELECT job_name FROM dba_scheduler_jobs
DOC>            WHERE job_name like 'UTL_RECOMP_SLAVE_%';
DOC>
DOC>   2. Query showing UTL_RECOMP jobs that are running
DOC>         SELECT job_name FROM dba_scheduler_running_jobs
DOC>            WHERE job_name like 'UTL_RECOMP_SLAVE_%';
DOC>#
SQL>
SQL> DECLARE
  2     threads pls_integer := &&1;
  3  BEGIN
  4     utl_recomp.recomp_parallel(threads);
  5  END;
  6  /

PL/SQL procedure successfully completed.

Elapsed: 00:16:59.37
SQL>
SQL> SELECT dbms_registry_sys.time_stamp('utlrp_end') as timestamp from dual;

TIMESTAMP
--------------------------------------------------------------------------------
COMP_TIMESTAMP UTLRP_END              2021-02-23 13:16:31

1 row selected.

Elapsed: 00:00:00.57
SQL>
SQL> Rem #(8264899): The code to Re-enable functional indexes, which used to exist
SQL> Rem here, is no longer needed.
SQL>
SQL> DOC
DOC> The following query reports the number of invalid objects.
DOC>
DOC> If the number is higher than expected, please examine the error
DOC> messages reported with each object (using SHOW ERRORS) to see if they
DOC> point to system misconfiguration or resource constraints that must be
DOC> fixed before attempting to recompile these objects.
DOC>#
SQL> select COUNT(*) "OBJECTS WITH ERRORS" from obj$ where status in (3,4,5,6);

OBJECTS WITH ERRORS
-------------------
                  0

1 row selected.

Elapsed: 00:00:00.01
SQL>
SQL>
SQL> DOC
DOC> The following query reports the number of exceptions caught during
DOC> recompilation. If this number is non-zero, please query the error
DOC> messages in the table UTL_RECOMP_ERRORS to see if any of these errors
DOC> are due to misconfiguration or resource constraints that must be
DOC> fixed before objects can compile successfully.
DOC> Note: Typical compilation errors (due to coding errors) are not
DOC>       logged into this table: they go into DBA_ERRORS instead.
DOC>#
SQL> select COUNT(*) "ERRORS DURING RECOMPILATION" from utl_recomp_errors;

ERRORS DURING RECOMPILATION
---------------------------
                          0

1 row selected.

Elapsed: 00:00:00.07
SQL>
SQL> Rem =====================================================================
SQL> Rem Reenable indexes that may have been disabled, based on the
SQL> Rem table SYS.ENABLED$INDEXES
SQL> Rem =====================================================================
SQL>
SQL> @@?/rdbms/admin/reenable_indexes.sql
SQL> Rem
SQL> Rem $Header: rdbms/admin/reenable_indexes.sql /main/6 2018/07/25 13:49:55 surman Exp $
SQL> Rem
SQL> Rem reenable_indexes.sql
SQL> Rem
SQL> Rem Copyright (c) 2014, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      reenable_indexes.sql - <one-line expansion of the name>
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      <short description of component this file declares/defines>
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      <other useful comments, qualifications, etc.>
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/reenable_indexes.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/reenable_indexes.sql
SQL> Rem    SQL_PHASE: REENABLE_INDEXES
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
SQL> Rem    sylin       01/30/15 - bug20422151 - longer identifier
SQL> Rem    surman      01/08/15 - 19475031: Update SQL metadata
SQL> Rem    pyam        04/03/14 - Reenable indexes based on sys.enabled$indexes
SQL> Rem                           (formerly in utlprp.sql)
SQL> Rem    pyam        04/03/14 - Created
SQL> Rem
SQL>
SQL> Rem
SQL> Rem Declare function local_enquote_name to pass FALSE
SQL> Rem into underlying dbms_assert.enquote_name function
SQL> Rem
SQL> CREATE OR REPLACE FUNCTION local_enquote_name (str varchar2)
  2   return varchar2 is
  3     begin
  4          return dbms_assert.enquote_name(str, FALSE);
  5     end local_enquote_name;
  6  /

Function created.

Elapsed: 00:00:00.28
SQL> Rem
SQL> Rem If sys.enabled$index table exists, then re-enable
SQL> Rem list of functional indexes that were enabled prior to upgrade
SQL> Rem The table sys.enabled$index table is created in catupstr.sql
SQL> Rem
SQL> SET serveroutput on
SQL> DECLARE
  2     TYPE tab_char IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;
  3     commands tab_char;
  4     p_null   CHAR(1);
  5     p_schemaname  dbms_id;
  6     p_indexname   dbms_id;
  7     rebuild_idx_msg BOOLEAN := FALSE;
  8     non_existent_index exception;
  9     recycle_bin_objs exception;
 10     cannot_change_obj exception;
 11     no_such_table  exception;
 12     pragma exception_init(non_existent_index, -1418);
 13     pragma exception_init(recycle_bin_objs, -38301);
 14     pragma exception_init(cannot_change_obj, -30552);
 15     pragma exception_init(no_such_table, -942);
 16     type cursor_t IS REF CURSOR;
 17     reg_cursor   cursor_t;
 18
 19  BEGIN
 20     -- Check for existence of the table marking disabled functional indices
 21
 22     SELECT NULL INTO p_null FROM DBA_OBJECTS
 23     WHERE owner = 'SYS' and object_name = 'ENABLED$INDEXES' and
 24              object_type = 'TABLE' and rownum <=1;
 25
 26        -- Select indices to be re-enabled
 27        EXECUTE IMMEDIATE q'+
 28           SELECT 'ALTER INDEX ' ||
 29                   local_enquote_name(e.schemaname) || '.' ||
 30                   local_enquote_name(e.indexname) || ' ENABLE'
 31              FROM   enabled$indexes e, ind$ i
 32              WHERE  e.objnum = i.obj# AND bitand(i.flags, 1024) != 0 AND
 33                     bitand(i.property, 16) != 0+'
 34        BULK COLLECT INTO commands;
 35
 36        IF (commands.count() > 0) THEN
 37           FOR i IN 1 .. commands.count() LOOP
 38              BEGIN
 39              EXECUTE IMMEDIATE commands(i);
 40              EXCEPTION
 41                 WHEN NON_EXISTENT_INDEX THEN NULL;
 42                 WHEN RECYCLE_BIN_OBJS THEN NULL;
 43                 WHEN CANNOT_CHANGE_OBJ THEN rebuild_idx_msg := TRUE;
 44              END;
 45           END LOOP;
 46        END IF;
 47
 48        -- Output any indexes in the table that could not be re-enabled
 49        -- due to ORA-30552 during ALTER INDEX...ENBLE command
 50
 51        IF  rebuild_idx_msg THEN
 52         BEGIN
 53           DBMS_OUTPUT.PUT_LINE
 54  ('The following indexes could not be re-enabled and may need to be rebuilt:');
 55
 56           OPEN reg_cursor FOR
 57               'SELECT e.schemaname, e.indexname
 58                FROM   enabled$indexes e, ind$ i
 59                WHERE  e.objnum = i.obj# AND bitand(i.flags, 1024) != 0';
 60
 61           LOOP
 62             FETCH reg_cursor INTO p_schemaname, p_indexname;
 63             EXIT WHEN reg_cursor%NOTFOUND;
 64             DBMS_OUTPUT.PUT_LINE
 65                ('.... INDEX ' || p_schemaname || '.' || p_indexname);
 66           END LOOP;
 67           CLOSE reg_cursor;
 68
 69         EXCEPTION
 70              WHEN NO_DATA_FOUND THEN CLOSE reg_cursor;
 71              WHEN NO_SUCH_TABLE THEN CLOSE reg_cursor;
 72              WHEN OTHERS THEN CLOSE reg_cursor; raise;
 73         END;
 74
 75        END IF;
 76
 77        EXECUTE IMMEDIATE 'DROP TABLE sys.enabled$indexes';
 78
 79     EXCEPTION
 80        WHEN NO_DATA_FOUND THEN NULL;
 81
 82  END;
 83  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.30
SQL>
SQL> DROP function local_enquote_name;

Function dropped.

Elapsed: 00:00:00.11
SQL> SET serveroutput off
SQL>
SQL>
SQL> Rem =====================================================================
SQL> Rem Run component validation procedure
SQL> Rem =====================================================================
SQL>
SQL> SET serveroutput on
SQL> EXECUTE dbms_registry_sys.validate_components;

PL/SQL procedure successfully completed.

Elapsed: 00:00:22.07
SQL> SET serveroutput off
SQL>
SQL>
SQL> Rem ===========================================================================
SQL> Rem END utlrp.sql
SQL> Rem ===========================================================================
SQL>
SQL> -- remove the invalid non-Oracle objects from the skip list which was
SQL> -- added during the beginning of the noncdb_to_pdb_upg.sql script
SQL> EXEC sys.utl_recomp.truncate_utl_recomp_skip_list;

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.21
SQL>
SQL> -- 26434999: set global prefs back to original value
SQL> exec dbms_stats.set_global_prefs('CONCURRENT','&concurrent')

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.18
SQL>
SQL> alter pluggable database "&pdbname" close immediate instances=all;

Pluggable database altered.

Elapsed: 00:00:15.54
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.06
SQL> alter pluggable database "&pdbname" open upgrade;

Pluggable database altered.

Elapsed: 00:00:09.96
SQL>
SQL>
SQL>
SQL> -- handle Resource Manager plan conversions
SQL> exec dbms_rmin.rm$_noncdb_to_pdb;

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.51
SQL>
SQL> -- delete SYS$BACKGROUND and SYS$USERS from service$
SQL> delete from sys.service$ where name in ('SYS$BACKGROUND', 'SYS$USERS');

0 rows deleted.

Elapsed: 00:00:00.01
SQL> commit;

Commit complete.

Elapsed: 00:00:00.00
SQL>
SQL> @@?/rdbms/admin/loc_to_common4.sql 2
SQL> Rem
SQL> Rem $Header: rdbms/admin/loc_to_common4.sql /main/13 2018/07/25 13:49:55 surman Exp $
SQL> Rem
SQL> Rem loc_to_common4.sql
SQL> Rem
SQL> Rem Copyright (c) 2014, 2018, Oracle and/or its affiliates.
SQL> Rem All rights reserved.
SQL> Rem
SQL> Rem    NAME
SQL> Rem      loc_to_common4.sql - helper script for converting local to common
SQL> Rem
SQL> Rem    DESCRIPTION
SQL> Rem      Does the fourth set of operations needed to convert local to common.
SQL> Rem      Cleans up views created in loc_to_common1.sql
SQL> Rem
SQL> Rem    NOTES
SQL> Rem      Called by noncdb_to_pdb.sql, apex_to_common.sql, pdb_to_apppdb.sql
SQL> Rem
SQL> Rem
SQL> Rem    BEGIN SQL_FILE_METADATA
SQL> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common4.sql
SQL> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common4.sql
SQL> Rem    SQL_PHASE: PDB
SQL> Rem    SQL_STARTUP_MODE: NORMAL
SQL> Rem    SQL_IGNORABLE_ERRORS: NONE
SQL> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
SQL> Rem    END SQL_FILE_METADATA
SQL> Rem
SQL> Rem    MODIFIED   (MM/DD/YY)
SQL> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
SQL> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
SQL> Rem    surman      03/13/18 - 27464252: Generic phase
SQL> Rem    thbaby      04/22/17 - Bug 25940936: set _enable_view_pdb
SQL> Rem    pyam        01/05/17 - set/clear scriptparam separately per container
SQL> Rem    pyam        09/08/16 - RTI 19633354: remove duplicate set &scriptparam
SQL> Rem    sankejai    01/22/16 - 16076261: session parameters scoped to container
SQL> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
SQL> Rem    thbaby      09/02/15 - Bug 21774247: handle COMMON_DATA
SQL> Rem    pyam        07/01/15 - set _APPLICATION_SCRIPT if applicable
SQL> Rem    vperiwal    03/26/15 - 20172151: add immediate instances = all for close
SQL> Rem    surman      01/08/15 - 19475031: Update SQL metadata
SQL> Rem    pyam        09/16/14 - Helper script #2 for converting local objects to
SQL> Rem                           common in a CDB environment.
SQL> Rem    pyam        09/16/14 - Created
SQL> Rem
SQL>
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.01
SQL>
SQL> COLUMN scriptparam NEW_VALUE scriptparam
SQL> select decode(&&1, 6, '"_APPLICATION_SCRIPT"', '"_ORACLE_SCRIPT"') scriptparam
  2    from dual;

SCRIPTPARAM
----------------
"_ORACLE_SCRIPT"

1 row selected.

Elapsed: 00:00:00.00
SQL> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> drop view sys.cdb$tables&pdbid;

View dropped.

Elapsed: 00:00:00.23
SQL> drop view sys.cdb$objects&pdbid;

View dropped.

Elapsed: 00:00:00.15
SQL> drop view sys.cdb$types&pdbid;

View dropped.

Elapsed: 00:00:00.02
SQL> drop view sys.cdb$common_root_objects&pdbid;

View dropped.

Elapsed: 00:00:00.01
SQL> drop view sys.cdb$cdata_root_tables&pdbid;

View dropped.

Elapsed: 00:00:00.01
SQL> drop view sys.cdb$cdata_root_views&pdbid;

View dropped.

Elapsed: 00:00:00.01
SQL> drop view sys.cdb$cmn_root_types&pdbid;

View dropped.

Elapsed: 00:00:00.04
SQL> drop view sys.cdb$common_users&pdbid;

View dropped.

Elapsed: 00:00:00.01
SQL> drop view sys.cdb$rootdeps&pdbid;

View dropped.

Elapsed: 00:00:00.00
SQL> drop view sys.cdb$commonsysprivs&pdbid;

View dropped.

Elapsed: 00:00:00.01
SQL> drop view sys.cdb$commonrolegrants&pdbid;

View dropped.

Elapsed: 00:00:00.01
SQL> drop view sys.cdb$commonobjprivs&pdbid;

View dropped.

Elapsed: 00:00:00.02
SQL>
SQL> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> alter session set container=&rootcon;

Session altered.

Elapsed: 00:00:00.12
SQL>
SQL> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.00
SQL> drop view sys.cdb$common_root_objects&pdbid;

View dropped.

Elapsed: 00:00:01.34
SQL> drop view sys.cdb$cdata_root_tables&pdbid;

View dropped.

Elapsed: 00:00:00.04
SQL> drop view sys.cdb$cdata_root_views&pdbid;

View dropped.

Elapsed: 00:00:00.04
SQL> drop view sys.cdb$cmn_root_types&pdbid;

View dropped.

Elapsed: 00:00:00.03
SQL> drop view sys.cdb$common_users&pdbid;

View dropped.

Elapsed: 00:00:00.04
SQL> drop view sys.cdb$rootdeps&pdbid;

View dropped.

Elapsed: 00:00:00.01
SQL> drop view sys.cdb$commonsysprivs&pdbid;

View dropped.

Elapsed: 00:00:00.03
SQL> drop view sys.cdb$commonrolegrants&pdbid;

View dropped.

Elapsed: 00:00:00.01
SQL> drop view sys.cdb$commonobjprivs&pdbid;

View dropped.

Elapsed: 00:00:00.05
SQL> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> alter session set container="&pdbname";

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- reset the parameters at the end of the script
SQL> exec dbms_pdb.noncdb_to_pdb(&&1);

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
SQL>
SQL> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.01
SQL>
SQL> Rem &&1 is 6 if fed
SQL>
SQL> COLUMN fedobjflag NEW_VALUE fedobjflag
SQL> select decode(&&1, 6, '134217728', '0') fedobjflag from dual;

F
-
0

1 row selected.

Elapsed: 00:00:00.00
SQL>
SQL> -- run ALTER TABLE UPGRADE on table dependents of common types
SQL> -- note this is done after noncdb_to_pdb(2), because between (1) and (2),
SQL> -- the driver was changed to only compute signatures
SQL> DECLARE
  2    cursor c is
  3      select u.name owner, o.name object_name
  4        from sys.obj$ o, sys.user$ u
  5      where o.type#=2 and u.user#=o.owner# and obj# in
  6        (select d_obj# from sys.dependency$ d, sys.obj$ typo where
  7         typo.type#=13 and typo.obj#=d.p_obj# and d.p_timestamp <> typo.stime and
  8         bitand(typo.flags, 196608)<>0 and
  9         bitand(typo.flags, 134217728)=&fedobjflag);
 10  BEGIN
 11    FOR tab in c
 12    LOOP
 13      BEGIN
 14        execute immediate 'ALTER TABLE ' ||
 15                          dbms_assert.enquote_name(tab.owner, FALSE) || '.' ||
 16                          dbms_assert.enquote_name(tab.object_name, FALSE) ||
 17                          ' UPGRADE';
 18      EXCEPTION
 19        WHEN OTHERS THEN
 20        BEGIN
 21          IF (sqlcode = -600 or sqlcode = -602 or sqlcode = -603) THEN
 22            raise;
 23          END IF;
 24        END;
 25      END;
 26    END LOOP;
 27    commit;
 28  END;
 29  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:04.68
SQL>
SQL> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> alter pluggable database "&pdbname" close immediate instances=all;

Pluggable database altered.

Elapsed: 00:00:00.62
SQL> alter session set container = CDB$ROOT;

Session altered.

Elapsed: 00:00:00.00
SQL> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.69
SQL> /

System altered.

Elapsed: 00:00:00.13
SQL> /

System altered.

Elapsed: 00:00:00.12
SQL> alter session set container = "&pdbname";

Session altered.

Elapsed: 00:00:00.01
SQL>
SQL> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
SQL>
SQL> -- leave the PDB in the same state it was when we started
SQL> BEGIN
  2    execute immediate '&open_sql &restricted_state';
  3  EXCEPTION
  4    WHEN OTHERS THEN
  5    BEGIN
  6      IF (sqlcode <> -900) THEN
  7        RAISE;
  8      END IF;
  9    END;
 10  END;
 11  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
SQL>
SQL> WHENEVER SQLERROR CONTINUE;
SQL>
SQL>
SQL>
SQL> select CON_ID,name,open_mode from v$containers;

    CON_ID
----------
NAME
--------------------------------------------------------------------------------
OPEN_MODE
----------
         4
PADAAN
MOUNTED


1 row selected.

Elapsed: 00:00:00.01
SQL> alter pluggable database open;

Pluggable database altered.

Elapsed: 00:00:19.35
SQL> set lines 250 pages 5000
SQL> select CON_ID,name,open_mode from v$containers;

    CON_ID NAME                                                                                                                             OPEN_MODE
---------- -------------------------------------------------------------------------------------------------------------------------------- ----------
         4 PADAAN                                                                                                                           READ WRITE

1 row selected.

Elapsed: 00:00:00.01
SQL> SELECT name, open_mode FROM v$pdbs;

NAME                                                                                                                             OPEN_MODE
-------------------------------------------------------------------------------------------------------------------------------- ----------
PADAAN                                                                                                                           READ WRITE

1 row selected.

Elapsed: 00:00:00.01
SQL> select name from v$tempfile union all select name from v$datafile union all select member from v$logfile;

NAME
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/data01/padaan/temp01.dbf
/data01/padaan/system01.dbf
/data01/padaan/sysaux01.dbf
/data01/padaan/undotbs01.dbf
/data01/padaan/users01.dbf
/z01/oradata/CPEMPEK/redo03.log
/z01/oradata/CPEMPEK/redo02.log
/z01/oradata/CPEMPEK/redo01.log

8 rows selected.

Elapsed: 00:00:00.02
SQL>  exit;
Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.10.0.0.0
[oracle@bakso ~]$ ls -lh /data01/
total 4.0K
drwxr-x---. 2 oracle oinstall 4.0K Feb 23 11:10 LEMPER
drwxr-xr-x. 2 oracle oinstall  104 Feb 23 12:42 padaan
[oracle@bakso ~]$ ls -lh /data01/LEMPER/
total 2.9G
-rw-r-----. 1 oracle oinstall  11M Feb 23 12:30 control01.ctl
-rw-r-----. 1 oracle oinstall 201M Feb 23 11:40 redo01.log
-rw-r-----. 1 oracle oinstall 201M Feb 23 11:40 redo02.log
-rw-r-----. 1 oracle oinstall 201M Feb 23 12:17 redo03.log
-rw-r-----. 1 oracle oinstall 651M Feb 23 12:27 sysaux01.dbf
-rw-r-----. 1 oracle oinstall 961M Feb 23 12:27 system01.dbf
-rw-r-----. 1 oracle oinstall 110M Feb 23 11:48 temp01.dbf
-rw-r-----. 1 oracle oinstall 591M Feb 23 12:27 undotbs01.dbf
-rw-r-----. 1 oracle oinstall 5.1M Feb 23 12:27 users01.dbf
[oracle@bakso ~]$ export ORACLE_SID=lemper; env|grep ORA; sqlplus '/ as sysdba'
ORACLE_SID=lemper
ORACLE_BASE=/z01/app/oracle
ORACLE_HOSTNAME=bakso.food.net
ORA_INVENTORY=/z01/app/oraInventory
ORACLE_HOME=/z01/app/oracle/product/19.0.0/dbhome_1

SQL*Plus: Release 19.0.0.0.0 - Production on Tue Feb 23 13:31:13 2021
Version 19.10.0.0.0

Copyright (c) 1982, 2020, Oracle.  All rights reserved.

Connected to an idle instance.

SQL> startup mount exclusive restrict;
ORACLE instance started.

Total System Global Area 1610609192 bytes
Fixed Size                  8897064 bytes
Variable Size             603979776 bytes
Database Buffers          989855744 bytes
Redo Buffers                7876608 bytes
Database mounted.
SQL> drop database;

Database dropped.

Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.10.0.0.0
Elapsed: 00:00:14.56
SQL> exit;
[oracle@bakso ~]$ lsnrctl status LISTENER

LSNRCTL for Linux: Version 19.0.0.0.0 - Production on 23-FEB-2021 13:55:17

Copyright (c) 1991, 2020, Oracle.  All rights reserved.

Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=bakso.food.net)(PORT=1521)))
STATUS of the LISTENER
------------------------
Alias                     LISTENER
Version                   TNSLSNR for Linux: Version 19.0.0.0.0 - Production
Start Date                23-FEB-2021 11:01:45
Uptime                    0 days 2 hr. 53 min. 32 sec
Trace Level               off
Security                  ON: Local OS Authentication
SNMP                      OFF
Listener Parameter File   /z01/app/oracle/product/19.0.0/dbhome_1/network/admin/listener.ora
Listener Log File         /z01/app/oracle/diag/tnslsnr/bakso/listener/alert/log.xml
Listening Endpoints Summary...
  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=bakso.food.net)(PORT=1521)))
  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521)))
  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcps)(HOST=bakso.food.net)(PORT=5500))(Security=(my_wallet_directory=/z01/app/oracle/admin/cpempek/xdb_wallet))(Presentation=HTTP)(Session=RAW))
Services Summary...
Service "86b637b62fdf7a65e053f706e80a27ca.food.net" has 1 instance(s).
  Instance "cpempek", status READY, has 1 handler(s) for this service...
Service "ba844edcf7233d1be0530338a8c0d602.food.net" has 1 instance(s).
  Instance "cpempek", status READY, has 1 handler(s) for this service...
Service "bbfa19632dad155ee0530338a8c06b99.food.net" has 1 instance(s).
  Instance "cpempek", status READY, has 1 handler(s) for this service...
Service "cpempek.food.net" has 1 instance(s).
  Instance "cpempek", status READY, has 1 handler(s) for this service...
Service "cpempekXDB.food.net" has 1 instance(s).
  Instance "cpempek", status READY, has 1 handler(s) for this service...
Service "padaan.food.net" has 1 instance(s).
  Instance "cpempek", status READY, has 1 handler(s) for this service...
Service "plenjer.food.net" has 1 instance(s).
  Instance "cpempek", status READY, has 1 handler(s) for this service...
The command completed successfully
[oracle@bakso ~]$ cd $ORACLE_HOME/OPatch
[oracle@bakso OPatch]$ source ~/.bash_profile
[oracle@bakso OPatch]$ env|grep ORA
ORACLE_SID=cpempek
ORACLE_BASE=/z01/app/oracle
ORACLE_HOSTNAME=bakso.food.net
ORA_INVENTORY=/z01/app/oraInventory
ORACLE_HOME=/z01/app/oracle/product/19.0.0/dbhome_1
[oracle@bakso OPatch]$ ./datapatch -verbose
SQL Patching tool version 19.10.0.0.0 Production on Tue Feb 23 13:57:29 2021
Copyright (c) 2012, 2020, Oracle.  All rights reserved.

Log file for this invocation: /z01/app/oracle/cfgtoollogs/sqlpatch/sqlpatch_18650_2021_02_23_13_57_29/sqlpatch_invocation.log

Connecting to database...OK
Gathering database info...done

Note:  Datapatch will only apply or rollback SQL fixes for PDBs
       that are in an open state, no patches will be applied to closed PDBs.
       Please refer to Note: Datapatch: Database 12c Post Patch SQL Automation
       (Doc ID 1585822.1)

Bootstrapping registry and package to current versions...done
Determining current state...done

Current state of interim SQL patches:
  No interim patches found

Current state of release update SQL patches:
  Binary registry:
    19.10.0.0.0 Release_Update 210108185017: Installed
  PDB CDB$ROOT:
    Applied 19.10.0.0.0 Release_Update 210108185017 successfully on 05-FEB-21 10.36.57.819585 AM
  PDB PADAAN:
    Applied 19.10.0.0.0 Release_Update 210108185017 successfully on 23-FEB-21 11.31.43.418225 AM
  PDB PDB$SEED:
    Applied 19.10.0.0.0 Release_Update 210108185017 successfully on 05-FEB-21 10.37.05.791025 AM
  PDB PLENJER:
    Applied 19.10.0.0.0 Release_Update 210108185017 successfully on 05-FEB-21 10.37.13.589467 AM

Adding patches to installation queue and performing prereq checks...done
Installation queue:
  For the following PDBs: CDB$ROOT PDB$SEED PLENJER PADAAN
    No interim patches need to be rolled back
    No release update patches need to be installed
    No interim patches need to be applied

SQL Patching tool complete on Tue Feb 23 13:58:33 2021
[oracle@bakso OPatch]$